#Fri Feb 10 12:25:39 IST 2023
[condition][]the_section {section} with field {field} is not unique accross all occurences then errorcode {errorcode}=(virtualIsUnique({section},(xcb.xpath({field})).stringValue(),{errorcode}))
[condition][]it is not true that_the field value {fieldvalue} matches the pattern {pattern}=(!((new SpecialFormat()).isPatternMatches((xcb.xpath({fieldvalue})).stringValue(),{pattern})))
[condition][]the field{field} with segment{segment} equals{value}=((new Position()).compareSpecifiedSegmentWithValue((xcb.xpath({field})).stringValue(),{segment},{value}))
[condition][]the {field} has_an abbreviation name=((new ThoroughFareHelper()).fetchAbbreviationName((xcb.xpath({field})).stringValue()))
[condition][]qtyCheckForCktact {var0} {var1} {var2} =((new Occurence()).qtyCheckForCktact({var0},{var1},{var2}))
[condition][]segmentRangeIsNumericWithLeadingSpaces {var0} {var1} {var2} {var3} =((new LengthCheck()).segmentRangeIsNumericWithLeadingSpaces({var0},{var1},{var2},{var3}))
[condition][]the {field} has_not a valid value{commaseperatedvalues}=((new isValidValue()).isNotValidValue((xcb.xpath({field})).stringValue(),{commaseperatedvalues}))
[condition][]setSvcNameUOM {var0} =((new SvcType()).setSvcNameUOM({var0}))
[condition][]any of the occurance of {fieldwithxpath} exists=((new Occurence()).anyOccurenceExists((xcb.xpath({fieldwithxpath})).stringValue()))
[condition][]the minimum length of {field} is {value}=((new LengthCheck()).checkMinimumLength((xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_set the request type of to {var0}=(!((new ReqTypeAct()).setRequestType({var0})))
[condition][]it is not true that_the {field} has_date format as check3 {YYMMDD}=(!((new DateFormatCheck()).dateCheck3((xcb.xpath({field})).stringValue(),{YYMMDD})))
[condition][]comparePrevVerAndCurrVerFieldValue {var0} {var1} {var2} {var3} {var4} {var5} {var6} {var7} {var8} {var9} {var10} =((new SuplementOrderCheck()).comparePrevVerAndCurrVerFieldValue({var0},{var1},{var2},{var3},{var4},{var5},{var6},{var7},{var8},{var9},{var10}))
[condition][]from the {pos1} to {pos2} has {format} for the {field}=((new DateFormatCheck()).time_format_chk({pos1},{pos2},{format},(xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the field {fieldname} of {parentname} with value {fieldvalue} differs from previous version tag value for the pon {PON} version {VER} ccna {CCNA} and icsc{ICSC} and compare with {val1} {val2}=(!((new SuplementOrderCheck()).CHKVAR_Access((xcb.xpath({fieldname})).stringValue(),{parentname},(xcb.xpath({fieldvalue})).stringValue(),{PON},{VER},{CCNA},{ICSC},{val1},{val2})))
[condition][]it is not true that_the {field} is populated=(!((new Populated()).isPopulated((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_positionOfAnyFieldNotEqualToCharacter {var0} {var1} {var2} =(!((new Occurence()).positionOfAnyFieldNotEqualToCharacter({var0},{var1},{var2})))
[condition][]it is not true that_getLatestValidVersionInDataBaseWithStatus {var0} {var1} {var2} =(!((new SuplementOrderCheck()).getLatestValidVersionInDataBaseWithStatus({var0},{var1},{var2})))
[condition][]it is not true that_the {field} contains numeric values followed by lowercase Alpha Characters=(!((new CapitalLetterCheck()).fieldContainsNumericValuesFollowedByLowercaseAlphaCharacters((xcb.xpath({field})).stringValue())))
[condition][]virtualisIntervalDurationMatchingForNc {var0} {var1} =(virtualisIntervalDurationMatchingForNc({var0},{var1}))
[condition][]setICSCLicense {var0} =((new SvcType()).setICSCLicense({var0}))
[condition][]it is not true that_the {pos} position_of {field} is not_equal_to_values {commaseperatedvalues}=(!(virtualPositionOftagValueNotEqualToValues({pos},(xcb.xpath({field})).stringValue(),{commaseperatedvalues})))
[condition][]it is not true that_the {field} contains alpha characters=(!((new Contains()).containsAlpha((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {field} contains all lowercase alpha characters directly preceded by a numeric character=(!((new CapitalLetterCheck()).lowercaseAlphaCharactersPreceededByNumeric((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {field} has_date format check1 {format1}=(!((new DateFormatCheck()).dateCheck1((xcb.xpath({field})).stringValue(),{format1})))
[condition][]it is not true that_the sup {SupFieldValue} is populated with pon {PonFieldValue} and version {VerFieldValue} and ccna {CcnaFieldValue} and icsc {IcscFieldValue} on the current order and does not have same {CCNAICSC} on the previous order=(!((new SuplementOrderCheck()).checkCcnaIcscActWithPreviousVersion({SupFieldValue},{PonFieldValue},{VerFieldValue},{CcnaFieldValue},{IcscFieldValue},{CCNAICSC})))
[condition][]segmentValueEqualToValues {var0} {var1} {var2} =((new Equals()).segmentValueEqualToValues({var0},{var1},{var2}))
[condition][]it is not true that_the {field} is compared with its position {pos1} to {pos2} with values {values}=(!((new Position()).compareCharAtAnyPositionWithAnyNumberOfValue((xcb.xpath({field})).stringValue(),{pos1},{pos2},{values})))
[condition][]the {field} has_the specified segment with number {segnum} whose length is less than specified {length}=((new LengthCheck()).segmentNumberLengthLessThan((xcb.xpath({field})).stringValue(),{segnum},{length}))
[condition][]eachCharacterPreceededOrFollowedByNumeric {var0} {var1} =((new Contains()).eachCharacterPreceededOrFollowedByNumeric({var0},{var1}))
[condition][]it is not true that_the {fieldwithxpath} is required=(!((new Required()).isRequired((xcb.xpath({fieldwithxpath})).stringValue())))
[condition][]the {field} has_specified segment {segnum} which contains alpha numeric characters with virgule or period as delimiter=((new DatatypeCheck()).virguleandPeriodSegmentEqualToAlphaNumeric((xcb.xpath({field})).stringValue(),{segnum}))
[condition][]it is not true that_the fields NC {NC} NCI {NCI} and SECNCI {SECNCI} are not compatible with database=(!((new ASOGTABLE()).checkNcNciCompatibility({NC},{NCI},{SECNCI})))
[condition][]it is not true that_the {field} is equal or greater than {value}=(!((new Equals()).isEqualOrGreaterThan((xcb.xpath({field})).stringValue(),{value})))
[condition][]it is not true that_presenceOfSpaceOtherThanSpecifiedPosition {var0} {var1} =(!((new Position()).presenceOfSpaceOtherThanSpecifiedPosition({var0},{var1})))
[condition][]it is not true that_the position_of Alpha is {pos} in {field}=(!((new DatatypeCheck()).checkPositionAlpha({pos},(xcb.xpath({field})).stringValue())))
[condition][]check for previous order based on pon and HDRICSC for the pon {pon} ccna{ccna} and icsc{icsc}=((new SuplementOrderCheck()).prevOrderCheckforHdrICSC({pon},{ccna},{icsc}))
[condition][]it is not true that_the {field} is Alpha with Special Characters Set {setofspecialcharacters}=(!((new DatatypeCheck()).checkAlphaSPSet((xcb.xpath({field})).stringValue(),{setofspecialcharacters})))
[condition][]it is not true that_characterFollowedBySpace {var0} {var1} =(!((new Contains()).characterFollowedBySpace({var0},{var1})))
[condition][]the field {field} is not numeric from postion {posn1} to position {posn2}=((new Contains()).positionalNotNumeric((xcb.xpath({field})).stringValue(),{posn1},{posn2}))
[condition][]the CCNA has_license for NCNCICOMPATIBILITY Table=((new SvcType()).getNCNCICompatibilityLicense())
[condition][]it is not true that_virtualoccOfOTCnEVMPIDwithinsameUNIMAPPING {section} {errorcode} =(!(virtualoccOfOTCnEVMPIDwithinsameUNIMAPPING({section},{errorcode})))
[condition][]the position {pos1} and {pos2} of {field} is between {startrange} and {endrange}=((new RangeOfValues()).twoFieldPositionInRange({pos1},{pos2},(xcb.xpath({field})).stringValue(),{startrange},{endrange}))
[condition][]noconfirmationOrderCheckDes pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}=((new SuplementOrderCheck()).noConfirmationOrderCheckDes({pon},{ver},{ccna},{icsc},{description}))
[condition][]it is not true that_noOfOccurancesOfTagValueIsUniqueForAnotherTagValueSet {var0} {var1} {var2} =(!((new Occurence()).noOfOccurancesOfTagValueIsUniqueForAnotherTagValueSet({var0},{var1},{var2})))
[condition][]the {section} for lref when uact is not equal to CKT with {errorcode}=(virtuallrefProhibitedWhenUactNotEqualsCNK({section},{errorcode}))
[condition][]anyARIPrilocAndPrilocSpotCheck {var0} {var1} {var2} =((new Occurence()).anyARIPrilocAndPrilocSpotCheck({var0},{var1},{var2}))
[condition][]the {fielddate1} is greater than or equal to {fielddate2}=((new DateCheck()).isGreaterThanOrEqualTo((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue()))
[condition][]the maximum length of the trimmed field {fieldvalue} is {length}=(virtualCheckMaximumLengthOfTrimmedTag((xcb.xpath({fieldvalue})).stringValue(),{length}))
[condition][]no of occurences of tag {fieldxpath1} with {field1} and {fieldxpath2} with {field2} are equal=((new Occurence()).noOfOccurencesOfBothTagAreEqualForSpecifiedPairValue((xcb.xpath({fieldxpath1})).stringValue(),(xcb.xpath({field1})).stringValue(),(xcb.xpath({fieldxpath2})).stringValue(),(xcb.xpath({field2})).stringValue()))
[condition][]the {pos} and {pos} of {field} is not_equal_to_values {CommaSeparatedValues}=((new Position()).twoPositionValueofTagNotEqualToValues({pos},{pos},(xcb.xpath({field})).stringValue(),{CommaSeparatedValues}))
[condition][]the field {field} populated with segment {segno} with optional character {character} does not contain {startLength} to {endLength} Alpha Numerics=((new LengthCheck()).checkSegmentNotPopulatedInLengthWithOptionalCharacter((xcb.xpath({field})).stringValue(),{segno},{character},{startLength},{endLength}))
[condition][]the {field} has_all uppercase characters for comma seperated values=((new CapitalLetterCheck()).isAllUpperCaseForCSV((xcb.xpath({field})).stringValue()))
[condition][]the field {fieldname} of {parentname} with value {fieldvalue} differs from previous version tag value for the pon {PON} version {VER} ccna {CCNA} and icsc{ICSC} and compare with {val1} {val2}=((new SuplementOrderCheck()).CHKVAR_Access((xcb.xpath({fieldname})).stringValue(),{parentname},(xcb.xpath({fieldvalue})).stringValue(),{PON},{VER},{CCNA},{ICSC},{val1},{val2}))
[condition][]it is not true that_atleast one occurence of{section} is populated=(!(virtualsaliAtleastOneOccurenceSectionPopulated1({section})))
[condition][]the occurance of {fieldwithxpath} is greaterthan {number}=((new Occurence()).noOfOccurenceGreaterThan((xcb.xpath({fieldwithxpath})).stringValue(),{number}))
[condition][]it is not true that_the{section}{subsect}{field} populated and assosiated tag{tag}is not populated or corresponding section tag{corrstag}not equals to {values}=(!(virtualLrefListFieldPopulatedAssoTagIsNotPopulatedOrCorrespondingTagNotEqualsVlaues({section},{subsect},(xcb.xpath({field})).stringValue(),{tag},{corrstag},{values})))
[condition][]routing matrix 1 value check when any ALL is present{section}{subsect}{field}=((new Occurence()).routingMatrixCheck1({section},{subsect},(xcb.xpath({field})).stringValue()))
[condition][]the {fielddate1} is greater than {fielddate2}=((new DateCheck()).isGreaterThan((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue()))
[condition][]it is not true that_the {sectn} has_the naickt{naiSectn} for the cancelled refnum{field} with value{value}=(!(virtualAnyNAICKTcheckForCancelledUREF({sectn},{naiSectn},(xcb.xpath({field})).stringValue(),{value})))
[condition][]virtualSegmentCount {var0} =(virtualSegmentCount({var0}))
[condition][]it is not true that_the {field} doesnot have {N} number of segments=(!((new LengthCheck()).fieldDoesNothaveNumberOfSegments((xcb.xpath({field})).stringValue(),{N})))
[condition][]it is not true that_the {fielddate1} is a Weekend=(!((new DateCheck()).isHoliday((xcb.xpath({fielddate1})).stringValue())))
[condition][]the {field} is Alpha without Special Characters Set {setofspecialcharacters}=((new DatatypeCheck()).checkAlphaWithOutSPSet((xcb.xpath({field})).stringValue(),{setofspecialcharacters}))
[condition][]it is not true that_the {field} is numeric followed by dot and is followed by numeric=(!((new RangeOfValues()).isNumericFollowedByDotFollowedByNumeric((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the field differs from previous version tag value for the pon {PON} version {VER} icsc{ICSC} and ccna{CCNA} {fieldname} of {parentname} at pos{POS} with field {fieldvalue}=(!((new SuplementOrderCheck()).tagValueDiffersInPreviousVersionatspecpos({PON},{VER},{ICSC},{CCNA},(xcb.xpath({fieldname})).stringValue(),{parentname},{POS},(xcb.xpath({fieldvalue})).stringValue())))
[condition][]the {field} has_specified {segmentNumber} field not equal to alpha with virgule or period as delimiter=((new DatatypeCheck()).virguleandPeriodSegmentNotEqualToAlpha((xcb.xpath({field})).stringValue(),{segmentNumber}))
[condition][]the {pos} and {pos} position_of the {field} is greater than or equal to {pos} and {pos} position=((new Position()).twoPositionValueofTagIsGreaterThanOrEqualToTheValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos}))
[condition][]it is not true that_the {field} is AlphaNumeric with Special Characters=(!((new DatatypeCheck()).checkAlphaNumericSP((xcb.xpath({field})).stringValue())))
[condition][]the {field} is Prohibited=((new Prohibited()).isProhibited((xcb.xpath({field})).stringValue()))
[condition][] new ReqTypeAct  getActivity  =((new ReqTypeAct()).getActivity())
[condition][]it is not true that_the {fieldvalue} is in HHMMA HHMMP format and the difference is equal to or greater than {value} hours=(!((new TimeFormatCheck()).appointmentTimeFormatRange((xcb.xpath({fieldvalue})).stringValue(),{value})))
[condition][]it is not true that_segact of ARI{ari} {segact} and RING{ring} value check with errorcode {errorcode}=(!(virtualSegactValueCheck({ari},{segact},{ring},{errorcode})))
[condition][]lrefListFieldIsNotPopulatedAssoTagIsPopulatedandCorrespondingTagEqualsVlaue {var0} {var1} {var2} {var3} {var4} {var5} {var6} =((new Occurence()).lrefListFieldIsNotPopulatedAssoTagIsPopulatedandCorrespondingTagEqualsVlaue({var0},{var1},{var2},{var3},{var4},{var5},{var6}))
[condition][]the {field} from positions {pos1} to {pos2} is populated or spaces=((new Populated()).rangeOfPositionIsPopulatedOrSpaces((xcb.xpath({field})).stringValue(),{pos1},{pos2}))
[condition][]the{section}{field} is not numerics with {errorcode}=((new Occurence()).VirtualResponseDataTypeNumericCheck({section},(xcb.xpath({field})).stringValue(),{errorcode}))
[condition][]it is not true that_the_section {section} with field {field} is not unique accross all occurences then errorcode {errorcode}=(!(virtualIsUnique({section},(xcb.xpath({field})).stringValue(),{errorcode})))
[condition][]it is not true that_any of the occurance of {fieldwithxpath} exists=(!((new Occurence()).anyOccurenceExists((xcb.xpath({fieldwithxpath})).stringValue())))
[condition][]allOccurenceOfFieldEqualToValue {var0} {var1} =((new Occurence()).allOccurenceOfFieldEqualToValue({var0},{var1}))
[condition][]it is not true that_routing matrix value check{section}{subsect}{field}=(!(virtualRoutingMatrixCheck({section},{subsect},(xcb.xpath({field})).stringValue())))
[condition][]noconfirmationOrderCheckNew pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}dedicate_recieve_customer{drc}=((new SuplementOrderCheck()).noConfirmationOrderCheckNew({pon},{ver},{ccna},{icsc},{description},{drc}))
[condition][]setSvcName {var0} =((new SvcType()).setSvcName({var0}))
[condition][]it is not true that_the {field} has_AND which is preceeded and followed by space=(!((new SpaceCheck()).isAndPrecFollSpace((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {field} has_specified {segmentNumber} not equal to space=(!((new DatatypeCheck()).segmentNotEqualToSpace((xcb.xpath({field})).stringValue(),{segmentNumber})))
[condition][]it is not true that_the interval between {fielddate1} and {fielddate2} is equal to {days}=(!((new DateCheck()).intervalBetweenTwoDateIsEqualtoDays((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue(),{days})))
[condition][]it is not true that_the difference between {fielddate1} and {fielddate2} is less than one year=(!((new DateCheck()).isRangeLesserThanOneYear((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue())))
[condition][]it is not true that_the {pos} and {pos} of {field} is_equal_to_values {CommaSeparatedValues}=(!((new Position()).twoPositionValueofTagEqualToValues({pos},{pos},(xcb.xpath({field})).stringValue(),{CommaSeparatedValues})))
[condition][]it is not true that_the substring after colon of the {field} equals {values}=(!((new SvcType()).compareSvcTypeAfterColon((xcb.xpath({field})).stringValue(),{values})))
[condition][]it is not true that_the {field} having last {N} characters {chars} are preced by numeric=(!((new Equals()).lastNcharsprecededbynumeric((xcb.xpath({field})).stringValue(),{N},{chars})))
[condition][]it is not true that_the {field} contains trailing space character=(!((new SpaceCheck()).checktrailspaces((xcb.xpath({field})).stringValue())))
[condition][]the {field} contains {num} of consecutive lowercase Alpha Characters=((new CapitalLetterCheck()).containsConsecutiveLowercaseAlphaCharacters((xcb.xpath({field})).stringValue(),{num}))
[condition][]it is not true that_spaceFollowedBySpace {var0} =(!((new Contains()).spaceFollowedBySpace({var0})))
[condition][]it is not true that_checkTagValue pon {field} ver {field} ccna {field} icsc {field} section {section} tag {tag} equalsvalue {value} pos {pos}InRequestforResponse=(!((new SuplementOrderCheck()).checkTagValueInRequestforResponse((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),{section},{tag},{value},{pos})))
[condition][]it is not true that_valueOfFieldIsOneGreaterThanOccurenceOfAnotherField {var0} {var1} =(!((new Occurence()).valueOfFieldIsOneGreaterThanOccurenceOfAnotherField({var0},{var1})))
[condition][]it is not true that_setICSCNCNCICompatibilityLicense {var0} =(!((new SvcType()).setICSCNCNCICompatibilityLicense({var0})))
[condition][]it is not true that_the pon {field} ver {field} section {section} tag {tag} at {pos} is populated in Request against Response=(!((new SuplementOrderCheck()).checkResponseTagExistInRequestatPosition((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),{section},{tag},{pos})))
[condition][]it is not true that_the {field} is according to the specified {format}=(!((new SpecialFormat()).isFieldAccordingToFormat((xcb.xpath({field})).stringValue(),{format})))
[condition][]it is not true that_the field{field} with segment{segment} equals{value}=(!((new Position()).compareSpecifiedSegmentWithValue((xcb.xpath({field})).stringValue(),{segment},{value})))
[condition][]the interval between {fielddate1} and {fielddate2} is greater than or equal to {days}=((new DateCheck()).intervalBetweenTwoDateIsGreaterThanOrEqualToDays((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue(),{days}))
[condition][]the interval between {fielddate1} and {fielddate2} is less than or equal to {days}=((new DateCheck()).intervalBetweenTwoDateIsLessThanOrEqualtoDays((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue(),{days}))
[condition][]it is not true that_segmentValueEqualToValues {var0} {var1} {var2} =(!((new Equals()).segmentValueEqualToValues({var0},{var1},{var2})))
[condition][]the difference for the given {CCNA} {NC} and {ICSC} between the {ASRDDD} and the current date is less than the Interval Duration from the table=((new IntervalDurationMatcher()).isIntervalDurationMatching({CCNA},{NC},{ICSC},{ASRDDD}))
[condition][]virtualOccurenceofEIandUACTinUNIMAPPING {section} {errorcode} =(virtualOccurenceofEIandUACTinUNIMAPPING({section},{errorcode}))
[condition][]the field {field} with space in range {start} and {end}=((new SpaceCheck()).existenceOfSpaceInSpecRange((xcb.xpath({field})).stringValue(),{start},{end}))
[condition][]the {field} is not numeric with special character set{spcharacters}=((new DatatypeCheck()).notNumericWithAllSpSet((xcb.xpath({field})).stringValue(),{spcharacters}))
[condition][]it is not true that_the {field} contains {num} of consecutive spaces after Alpha Characters=(!((new CapitalLetterCheck()).containsConsecutiveSpacesAfterAlphaCharacters((xcb.xpath({field})).stringValue(),{num})))
[condition][]the {field} has_both uppercase and lowercase characters for comma seperated vaules=((new CapitalLetterCheck()).isUpperAndLowerCaseForCSV((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_checkAnyPositionsInRangeContainsValues {var0} {var1} {var2} {var3} =(!((new Position()).checkAnyPositionsInRangeContainsValues({var0},{var1},{var2},{var3})))
[condition][]the {field} has_the specified segment with number {segnum} whose length is in range {min} to {max} with leading spaces to support virgule or period as delimiter=((new LengthCheck()).virguleandPeriodSegmentRangeIsNumericWithLeadingSpaces((xcb.xpath({field})).stringValue(),{segnum},{min},{max}))
[condition][]it is not true that_any occurance{fieldwithxpath}fieldisPopulated=(!((new Occurence()).anyOccurenceOfFieldPopulated((xcb.xpath({fieldwithxpath})).stringValue())))
[condition][]checkForLowerCaseLettersAfterNumbers {var0} =((new CapitalLetterCheck()).checkForLowerCaseLettersAfterNumbers({var0}))
[condition][]it is not true that_{xpath} is unique=(!((new Unique()).isUnique({xpath})))
[condition][]the {fieldwithxpath} is not required=((new Required()).isNotRequired((xcb.xpath({fieldwithxpath})).stringValue()))
[condition][]the {field} is less than {value}=((new Equals()).isLessThan((xcb.xpath({field})).stringValue(),{value}))
[condition][]setNCNCICompatibilityLicense  {var0} =((new SvcType()).setNCNCICompatibilityLicense({var0}))
[condition][]it is not true that_the {fielddate1} is less than {fielddate2}=(!((new DateCheck()).isLessThan((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue())))
[condition][]it is not true that_check previous versison servicetype for the pon {PonFieldValue} and version {VerFieldValue} and ccna {CcnaFieldValue} and icsc {IcscFieldValue} with current rootnode value {RootnodeValue}=(!((new SuplementOrderCheck()).checkServiceTypeInPreviousVersion({PonFieldValue},{VerFieldValue},{CcnaFieldValue},{IcscFieldValue},{RootnodeValue})))
[condition][]noOfOccurenceGreaterThanValue {var0} {var1} =((new Occurence()).noOfOccurenceGreaterThanValue({var0},{var1}))
[condition][]it is not true that_the no of occurances of {fieldxpath} pair have different {fieldxpath} values=(!((new Occurence()).noOfOccurancesOfLactIOPairMustHaveDiffAliValue((xcb.xpath({fieldxpath})).stringValue(),(xcb.xpath({fieldxpath})).stringValue())))
[condition][]it is not true that_noconfirmationOrderCheckDes pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}=(!((new SuplementOrderCheck()).noConfirmationOrderCheckDes({pon},{ver},{ccna},{icsc},{description})))
[condition][]it is not true that_the {field} with segment {segnum} is not populated=(!((new Populated()).segmentIsNotPopulated((xcb.xpath({field})).stringValue(),{segnum})))
[condition][]it is not true that_the range of the {field} is A0 to Z9=(!((new RangeOfValues()).rangeCheckA0_Z9((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_duplicateOrder pon {pon} ver {ver} ccna {ccna} icsc {icsc} exists in DB=(!((new SuplementOrderCheck()).duplicateOrderCheck({pon},{ver},{ccna},{icsc})))
[condition][]it is not true that_all tags of unimapping {section} in current and previous version check {sup} {pon} {ver} {ccna} {icsc} {uact} {values} {uref} with {code}=(!((new Occurence()).VirtualUnimappingTagsCheckWIthPreviousVer({section},{sup},{pon},{ver},{ccna},{icsc},{uact},{values},{uref},{code})))
[condition][]it is not true that_the {field} has_words seperated by a comma=(!((new DatatypeCheck()).commaPresenceForMoreThanOneWord((xcb.xpath({field})).stringValue())))
[condition][]display the message {field}=((new DisplayMessage()).displayMessage((xcb.xpath({field})).stringValue()))
[condition][]any segment of the {fieldvalue} delimeted by space does not equal {commaseparatedvalues}=((new LengthCheck()).segmentsNotEquals((xcb.xpath({fieldvalue})).stringValue(),{commaseparatedvalues}))
[condition][]it is not true that_the {field} has_specified {segmentNumber} not equal to numeric=(!((new DatatypeCheck()).segmentNotEqualToNumeric((xcb.xpath({field})).stringValue(),{segmentNumber})))
[condition][]it is not true that_firstPositionRangeGreaterThanSecondPositionRange {var0} {var1} {var2} {var3} {var4} =(!((new Position()).firstPositionRangeGreaterThanSecondPositionRange({var0},{var1},{var2},{var3},{var4})))
[condition][]it is not true that_the ccna{ccna} and icsc{icsc} combination exists=(!((new SuplementOrderCheck()).checkCcnaIcscCombination({ccna},{icsc})))
[condition][]it is not true that_setSvcNameUOM {var0} =(!((new SvcType()).setSvcNameUOM({var0})))
[condition][]the {field} is AlphaNumeric=((new DatatypeCheck()).checkAlphaNumeric((xcb.xpath({field})).stringValue()))
[condition][]the multiple field {field} is not numeric in any occurence=((new Occurence()).dataTypeCheckForMultipleOccuringTag((xcb.xpath({field})).stringValue()))
[condition][]the field {field1} is greater than field {field2}=((new Equals()).field1IsGreaterThanField2((xcb.xpath({field1})).stringValue(),(xcb.xpath({field2})).stringValue()))
[condition][]virtualFS_CheckKeyValuePairExists {var0} {var1} =((new Occurence()).FS_CheckKeyValuePairExists({var0},{var1}))
[condition][]the order with asog version {ver} icsc {icsc} and {msgtimestamp} cannot be submitted because of ASOG Upgrade=(virtualAsogCutOverOrderReject({ver},{icsc},{msgtimestamp}))
[condition][]virtualoccurenceofuactNCI {vector} {list} {ncivalue} {errorcode} =(virtualoccurenceofuactNCI({vector},{list},{ncivalue},{errorcode}))
[condition][]it is not true that_the {field} has_only one {char} special character present=(!((new DatatypeCheck()).checkRepeationOFSpecialCharacter((xcb.xpath({field})).stringValue(),{char})))
[condition][]it is not true that_Number of occurence of Field {FieldXpath} is in range from {minvalue} To {maxvalue}=(!((new Occurence()).noOfOccurenceOfFieldInRange({FieldXpath},{minvalue},{maxvalue})))
[condition][]it is not true that_any Occurnce of {fieldwithxpath} is equal to {character} in {pos}positon=(!((new Occurence()).positionOfAnyFieldEqualToCharacter((xcb.xpath({fieldwithxpath})).stringValue(),{character},{pos})))
[condition][]it is not true that_virtualoccurenceofVACTandUACT2 {section} {errorcode} =(!(virtualoccurenceofVACTandUACT2({section},{errorcode})))
[condition][]any occurance of the {field1withxpath} is equal to {value}=((new Occurence()).anyOccurenceEqualToValue((xcb.xpath({field1withxpath})).stringValue(),{value}))
[condition][]it is not true that_the range of the {field} is AA to ZZ=(!((new RangeOfValues()).rangeCheckAA_ZZ((xcb.xpath({field})).stringValue())))
[condition][]the sup {SupFieldValue} is populated with pon {PonFieldValue} and version {VerFieldValue} and ccna {CcnaFieldValue} and icsc {IcscFieldValue} on the current order and does not have same {CCNAICSC} on the previous order=((new SuplementOrderCheck()).checkCcnaIcscActWithPreviousVersion({SupFieldValue},{PonFieldValue},{VerFieldValue},{CcnaFieldValue},{IcscFieldValue},{CCNAICSC}))
[condition][]it is not true that_check for previous order based on pon and HDRICSC for the pon {pon} ccna{ccna} and icsc{icsc}=(!((new SuplementOrderCheck()).prevOrderCheckforHdrICSC({pon},{ccna},{icsc})))
[condition][]the {field} has_specified segment {segnum} which contains alpha numeric characters=((new DatatypeCheck()).segmentEqualToAlphaNumeric((xcb.xpath({field})).stringValue(),{segnum}))
[condition][]spaceFollowedBySpace {var0} =((new Contains()).spaceFollowedBySpace({var0}))
[condition][]the pon {PON} ccna {CCNA} and icsc{ICSC} combination has_the response with description {DESCRIPTION} and the previous version SUP1 has_order with status {CURRENTSTATUS} for the xml {xmlins}=(virtual_prevOrderSUP1CheckWithRespReject({PON},{CCNA},{ICSC},{DESCRIPTION},{CURRENTSTATUS},{xmlins}))
[condition][]it is not true that_lrefListFieldIsNotPopulatedAssoTagIsPopulatedandCorrespondingTagEqualsVlaue {var0} {var1} {var2} {var3} {var4} {var5} {var6} =(!((new Occurence()).lrefListFieldIsNotPopulatedAssoTagIsPopulatedandCorrespondingTagEqualsVlaue({var0},{var1},{var2},{var3},{var4},{var5},{var6})))
[condition][]it is not true that_the {field} has_specified {segmentNumber} not equal to numeric with virgule or period as delimiter=(!((new DatatypeCheck()).virguleandPeriodSegmentNotEqualToNumeric((xcb.xpath({field})).stringValue(),{segmentNumber})))
[condition][]it is not true that_the {field} is_equal_to_values {CommaSeparatedValues}=(!((new Equals()).isEqualToValues((xcb.xpath({field})).stringValue(),{CommaSeparatedValues})))
[condition][]virtualoccurenceofVACTandUACTCEVLAN {var0} {var1} =(virtualoccurenceofVACTandUACTCEVLAN({var0},{var1}))
[condition][]it is not true that_checkResponse_IcscTagExistInRequestIcsc {var0} {var1} {var2} {var3} =(!((new SuplementOrderCheck()).checkResponse_IcscTagExistInRequestIcsc({var0},{var1},{var2},{var3})))
[condition][]it is not true that_the {field} has_two or more uppercase alphabets=(!((new CapitalLetterCheck()).twoOrMoreConsecUpperCaseAlpha((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_virtualALCONfieldPopulated {priloc} {secloc} {errorcode} =(!(virtualALCONfieldPopulated({priloc},{secloc},{errorcode})))
[condition][]it is not true that_the {segnum} segment of the {fieldvalue} is present in the LOCATION Table=(!(virtualSegmentFetchAbbreviationLOCATIONTable({segnum},(xcb.xpath({fieldvalue})).stringValue())))
[condition][]it is not true that_the{section}{subsect}{field}not populated and assosiated tag{tag}is populated and corresponding section tag{corrstag}equals to {values}=(!(virtualLrefListFieldIsNotPopulatedAssoTagIsPopulatedandCorrespondingTagEqualsVlaue({section},{subsect},(xcb.xpath({field})).stringValue(),{tag},{corrstag},{values})))
[condition][]anyOccurenceOfMultipleFieldIsPopulatedAndNotNumeric {var0} =((new Occurence()).anyOccurenceOfMultipleFieldIsPopulatedAndNotNumeric({var0}))
[condition][]it is not true that_no of occurences of tag {fieldxpath1} with {field1} and {fieldxpath2} with {field2} are equal=(!((new Occurence()).noOfOccurencesOfBothTagAreEqualForSpecifiedPairValue((xcb.xpath({fieldxpath1})).stringValue(),(xcb.xpath({field1})).stringValue(),(xcb.xpath({fieldxpath2})).stringValue(),(xcb.xpath({field2})).stringValue())))
[condition][]it is not true that_display the message {field}=(!((new DisplayMessage()).displayMessage((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {field} has_not a valid value{commaseperatedvalues}=(!((new isValidValue()).isNotValidValue((xcb.xpath({field})).stringValue(),{commaseperatedvalues})))
[condition][]it is not true that   new ReqTypeAct  getRequestType  =(!((new ReqTypeAct()).getRequestType()))
[condition][]it is not true that_noOfCharactersinTag {var0} {var1} {var2} =(!((new Contains()).NoOfCharactersinTag({var0},{var1},{var2})))
[condition][]it is not true that_any occurance of the {field1withxpath} is not equal to {value}=(!((new Occurence()).anyOccurenceNotEqualToValue((xcb.xpath({field1withxpath})).stringValue(),{value})))
[condition][]the {field} not equal to specified {value} of the specified {segnum}=((new Equals()).segmentValueNotEqualToEnteredValue((xcb.xpath({field})).stringValue(),{value},{segnum}))
[condition][]it is not true that_any of the {fieldwithxpath} has {character}=(!(virtualanyCharacterOfFieldIs((xcb.xpath({fieldwithxpath})).stringValue(),{character})))
[condition][]it is not true that_the {field}is not_equal_to_values {CommaSeparatedValues}=(!((new Equals()).isNotEqualToValues((xcb.xpath({field})).stringValue(),{CommaSeparatedValues})))
[condition][]the {field} has_a space which is followed by numeric=((new SpaceCheck()).spaceFollowedByNumeric((xcb.xpath({field})).stringValue()))
[condition][]the {pos} to {pos} of the {field1} is equal to {pos} to {pos} of the {field2}=((new Position()).twoPositionRangeValueofTagEqualToValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field1})).stringValue(),{pos},{pos},(xcb.xpath({field2})).stringValue()))
[condition][]getLatestVersion {var0} {var1} =((new SuplementOrderCheck()).getLatestVersion({var0},{var1}))
[condition][]the {field} has_the segment with specified {segnum} whose length is greater than specified {length}=((new LengthCheck()).segmentNumberLengthGreaterThan((xcb.xpath({field})).stringValue(),{segnum},{length}))
[condition][]it is not true that_the {fieldvalue} is present in NCMUX table =(!((new ASOGTABLE()).fetchAbbreviationNCMUXTable((xcb.xpath({fieldvalue})).stringValue())))
[condition][]the {pos} position_of {field} field_is_equal_to_values {commaseperatedvalues}=((new Position()).positionOftagValueEqualToValues({pos},(xcb.xpath({field})).stringValue(),{commaseperatedvalues}))
[condition][]the position {pos} of {field} is not_equal_to_values {commaseperatedvalues}=((new Position()).positionOftagValueNotEqualToValues({pos},(xcb.xpath({field})).stringValue(),{commaseperatedvalues}))
[condition][]it is not true that_the {field} is Required for {commaseperatedvalues}=(!((new Required()).requiredForValues((xcb.xpath({field})).stringValue(),{commaseperatedvalues})))
[condition][]lrefTagCheck {var0} {var1} {var2} {var3} =((new SuplementOrderCheck()).lrefTagCheck({var0},{var1},{var2},{var3}))
[condition][]the {fieldwithxpath} is required=((new Required()).isRequired((xcb.xpath({fieldwithxpath})).stringValue()))
[condition][]the {fieldvalue} is present on ICSC table=((new ASOGTABLE()).fetchAbbreviationICSCTable((xcb.xpath({fieldvalue})).stringValue()))
[condition][]it is not true that_the{section}{field} is not numerics with {errorcode}=(!((new Occurence()).VirtualResponseDataTypeNumericCheck({section},(xcb.xpath({field})).stringValue(),{errorcode})))
[condition][]section{section} tag{tag} not populated=(virtualNotPopulated({section},{tag}))
[condition][]it is not true that_the {field} has_a valid value {value}=(!((new isValidValue()).isValidValue((xcb.xpath({field})).stringValue(),{value})))
[condition][]it is not true that_the {fieldvalue} not equal to specified values {CommaSeparatedValues} of the specified {segnum}=(!((new Equals()).segmentValueNotEqualToValues((xcb.xpath({fieldvalue})).stringValue(),{CommaSeparatedValues},{segnum})))
[condition][]it is not true that_the {field} has_time format as {timeformat}=(!((new TimeFormatCheck()).timeFormat((xcb.xpath({field})).stringValue(),{timeformat})))
[condition][]the {field} contains embedded space=((new SpaceCheck()).containsEmbeddedSpace((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} has_the segment with specified {segnum} whose length is greater than specified {length}=(!((new LengthCheck()).segmentNumberLengthGreaterThan((xcb.xpath({field})).stringValue(),{segnum},{length})))
[condition][]it is not true that_the field {field} populated with segment {segno} with optional character {character} does not contain {startLength} to {endLength} Alpha Numerics=(!((new LengthCheck()).checkSegmentNotPopulatedInLengthWithOptionalCharacter((xcb.xpath({field})).stringValue(),{segno},{character},{startLength},{endLength})))
[condition][]it is not true that_the difference between {fielddate1} and {fielddate2} is less than or equal to one year=(!((new DateCheck()).isRangeLesserThanOrEqualToOneYear((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue())))
[condition][]it is not true that_the {field} has_telephone number format as {tnformat}=(!((new TNFormat()).tnFormatIs((xcb.xpath({field})).stringValue(),{tnformat})))
[condition][]it is not true that_the {field} contains embedded space=(!((new SpaceCheck()).containsEmbeddedSpace((xcb.xpath({field})).stringValue())))
[condition][]the {field} has_valid values {commaseperatedvalues}=((new isValidValue()).isValidValues((xcb.xpath({field})).stringValue(),{commaseperatedvalues}))
[condition][]it is not true that_the interval between {fielddate1} and {fielddate2} is greater than {days}=(!((new DateCheck()).intervalBetweenTwoDateIsGreaterThanDays((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue(),{days})))
[condition][]it is not true that_any segment of the {fieldvalue} delimeted by space does not equal {commaseparatedvalues}=(!((new LengthCheck()).segmentsNotEquals((xcb.xpath({fieldvalue})).stringValue(),{commaseparatedvalues})))
[condition][]the pon {field} ver {field} section {section} tag {tag} at {pos} is populated in Request against Response=((new SuplementOrderCheck()).checkResponseTagExistInRequestatPosition((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),{section},{tag},{pos}))
[condition][]the {field} has_specified {segmentNumber} not equal to numeric with virgule or period as delimiter=((new DatatypeCheck()).virguleandPeriodSegmentNotEqualToNumeric((xcb.xpath({field})).stringValue(),{segmentNumber}))
[condition][]it is not true that_spaceFollowedBySpaceFollowedByChar {var0} =(!((new SpaceCheck()).spaceFollowedBySpaceFollowedByChar({var0})))
[condition][]it is not true that_the {field} is equal or less than {value}=(!((new Equals()).isEqualOrLessThan((xcb.xpath({field})).stringValue(),{value})))
[condition][]the sup {SupFieldValue} is populated with pon {PonFieldValue} and version {VerFieldValue} and ccna {CcnaFieldValue} and icsc {IcscFieldValue} on the current order and matching with the previous order which has_a status CANCEL=((new SuplementOrderCheck()).supFieldCheck({SupFieldValue},{PonFieldValue},{VerFieldValue},{CcnaFieldValue},{IcscFieldValue}))
[condition][]the {field} contains {num} of consecutive spaces after Alpha Characters=((new CapitalLetterCheck()).containsConsecutiveSpacesAfterAlphaCharacters((xcb.xpath({field})).stringValue(),{num}))
[condition][]the field {fieldname} of {parentname} with value {fieldvalue} differs from previous version tag value for the pon {PON} version {VER} ccna {CCNA} and icsc{ICSC}=((new SuplementOrderCheck()).tagValueDiffersInPreviousVersion((xcb.xpath({fieldname})).stringValue(),{parentname},(xcb.xpath({fieldvalue})).stringValue(),{PON},{VER},{CCNA},{ICSC}))
[condition][]it is not true that_any occurance of the {field1withxpath} is equal to comma seperated values{values}=(!((new Occurence()).anyOccurenceEqualToValues((xcb.xpath({field1withxpath})).stringValue(),{values})))
[condition][]checkCancelledUrefExists {var0} {var1} {var2} {var3} {var4} {var5} {var6} =((new SuplementOrderCheck()).checkCancelledUrefExists({var0},{var1},{var2},{var3},{var4},{var5},{var6}))
[condition][]valueOfFieldIsOneGreaterThanOccurenceOfAnotherField {var0} {var1} =((new Occurence()).valueOfFieldIsOneGreaterThanOccurenceOfAnotherField({var0},{var1}))
[condition][]it is not true that_there is no {section} section=(!((new Populated()).isNotPopulatedSection({section})))
[condition][]it is not true that_the {pos} and {pos} position_of the {field} is equal to {pos} and {pos} position=(!((new Position()).twoPositionValueofTagEqualToValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos})))
[condition][]the {pos} position_of {field} is equal to {value}=((new Position()).positionOftagValueEqualToValue({pos},(xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_the pos{pos1} to {pos2} of the field {field} with specified segment {segnum} is equal to the pos{pos1} to {pos2} of another field {field}=(!((new Position()).segmentInPositionRangeEqualToNextFieldSpecifiedPositionRange({pos1},{pos2},(xcb.xpath({field})).stringValue(),{segnum},{pos1},{pos2},(xcb.xpath({field})).stringValue())))
[condition][]it is not true that_checkForLowerCaseLettersAfterNumbers {var0} =(!((new CapitalLetterCheck()).checkForLowerCaseLettersAfterNumbers({var0})))
[condition][]the version is {VER} not equal to the latest database version for the pon {PON} ccna {CCNA} and icsc{ICSC} with the status {STATUS}=((new SuplementOrderCheck()).verNotEqualToLatestDBVersion({VER},{PON},{CCNA},{ICSC},{STATUS}))
[condition][]duplicateOrder pon {pon} ver {ver} ccna {ccna} icsc {icsc} exists in DB=((new SuplementOrderCheck()).duplicateOrderCheck({pon},{ver},{ccna},{icsc}))
[condition][]it is not true that_containsSpaceInSpecRange {var0} {var1} {var2} =(!((new Contains()).containsSpaceInSpecRange({var0},{var1},{var2})))
[condition][]the difference between {fielddate1} and {fielddate2} is greater than or equal to one year=((new DateCheck()).isRangeGreaterThanOrEqualToOneYear((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue()))
[condition][]it is not true that_noOfOccurenceGreaterThanValue {var0} {var1} =(!((new Occurence()).noOfOccurenceGreaterThanValue({var0},{var1})))
[condition][]it is not true that_the pon {field} ver {field} section {section} tag {tag} is populated in Request against Response=(!((new SuplementOrderCheck()).checkResponseTagExistInRequest((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),{section},{tag})))
[condition][]it is not true that_the sup {SupFieldValue} is populated with pon {PonFieldValue} and version {VerFieldValue} and ccna {CcnaFieldValue} and icsc {IcscFieldValue} and the UNI_MAPPING section which had the field {FieldName} of values {commaseparatedvalues} and with all its elements of the previous order is not equal to none of the UNI_MAPPING section with all its elements in current order=(!((new SuplementOrderCheck()).checkActiveUrefDoesNotExists({SupFieldValue},{PonFieldValue},{VerFieldValue},{CcnaFieldValue},{IcscFieldValue},{FieldName},{commaseparatedvalues})))
[condition][]presenceOfSpaceOtherThanSpecifiedPosition {var0} {var1} =((new Position()).presenceOfSpaceOtherThanSpecifiedPosition({var0},{var1}))
[condition][]the {field} contains trailing space character=((new SpaceCheck()).checktrailspaces((xcb.xpath({field})).stringValue()))
[condition][]the {field} has_date format as check3 {YYMMDD}=((new DateFormatCheck()).dateCheck3((xcb.xpath({field})).stringValue(),{YYMMDD}))
[condition][]it is not true that_atleast one occurence of{section}{subsectn} is populated=(!(virtualsaliAtleastOneOccurenceSectionPopulated({section},{subsectn})))
[condition][]the {fielddate1} is todays date=((new DateCheck()).isToday((xcb.xpath({fielddate1})).stringValue()))
[condition][]it is not true that_if {pos1} and {pos2} not in foramt {chhp} for {fdt}=(!((new DateFormatCheck()).time_format_chkforFDT({pos1},{pos2},{chhp},{fdt})))
[condition][]checkAlphaNumericWithASingleSpecialCharacter {var0} {var1} =((new DatatypeCheck()).checkAlphaNumericWithASingleSpecialCharacter({var0},{var1}))
[condition][]the {field} has_two or more uppercase alphabets=((new CapitalLetterCheck()).twoOrMoreConsecUpperCaseAlpha((xcb.xpath({field})).stringValue()))
[condition][]tagValue {var0} =((new Occurence()).tagValue({var0}))
[condition][]it is not true that_positionOfAllFieldNotEqualToCharacter {var0} {var1} {var2} =(!((new Occurence()).positionOfAllFieldNotEqualToCharacter({var0},{var1},{var2})))
[condition][]it is not true that_the_section{section} with the field {field} is not consecutively assigned from value{value} with errorcode {errorcode}=(!(virtualFieldIsNotConsecutivelyAssignedAcrossOccurrences({section},(xcb.xpath({field})).stringValue(),{value},{errorcode})))
[condition][]the {field} is not Required=((new Required()).isNotRequired((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} has_ampersand which is not preceeded and followed by space=(!((new SpaceCheck()).isAmpersandNotPrecFollSpace((xcb.xpath({field})).stringValue())))
[condition][]any occurance{fieldwithxpath}fieldisPopulated=((new Occurence()).anyOccurenceOfFieldPopulated((xcb.xpath({fieldwithxpath})).stringValue()))
[condition][]virtualoccurenceofVACTandUACT2 {section} {errorcode} =(virtualoccurenceofVACTandUACT2({section},{errorcode}))
[condition][]the no of occurances of {fieldxpath} pair have different {fieldxpath} values=((new Occurence()).noOfOccurancesOfLactIOPairMustHaveDiffAliValue((xcb.xpath({fieldxpath})).stringValue(),(xcb.xpath({fieldxpath})).stringValue()))
[condition][]the segment {segnum} length of field {fieldvalue} is in the range {min} and {max}=((new LengthCheck()).segmentNumberLengthInRange({segnum},(xcb.xpath({fieldvalue})).stringValue(),{min},{max}))
[condition][]it is not true that_the interval between {fielddate1} and {fielddate2} is not equal to {days}=(!((new DateCheck()).intervalBetweenTwoDateIsNotEqualtoDays((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue(),{days})))
[condition][]the difference between {fielddate1} and {fielddate2} is less than one year=((new DateCheck()).isRangeLesserThanOneYear((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue()))
[condition][]the {field} is in the range ZL1 to ZL8=((new RangeOfValues()).rangeCheckZl1_Zl8((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_anyOccurenceOf{section}{tag} equals {commaseperatedvalues}=(!(virtualfieldEqualsValues({section},{tag},{commaseperatedvalues})))
[condition][]it is not true that_the {pos} and {pos} position_of the {field} is greater than {pos} and {pos} position=(!((new Position()).twoPositionValueofTagIsGreaterThanTheValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos})))
[condition][]the_section EVC {section} with sub section {subsect} for the field {field} is not conecutively assigned starting with {value} then errorcode {errorcode}=(virtuallrefIsNotConecutivelyAssignedStratingWIthValue({section},{subsect},(xcb.xpath({field})).stringValue(),{value},{errorcode}))
[condition][]it is not true that_the{section} {field} is not unique in all the occurences with code {code}=(!((new Occurence()).isUnique({section},(xcb.xpath({field})).stringValue(),{code})))
[condition][]Spec_Lrefchk{Lref} Lref{lref} spec{spec} and occurance{occurance} with errorCode {errorcode}=(virtualSpecLrefchk({Lref},{lref},{spec},{occurance},{errorcode}))
[condition][]it is not true that_Is the {field} of the specified {segnum} according to the format {format}=(!((new DateFormatCheck()).isSpecifiedSegmentInValidFormat((xcb.xpath({field})).stringValue(),{segnum},{format})))
[condition][]it is not true that_the field {field} has_pattern {pattern}=(!((new SpecialFormat()).patternChecking((xcb.xpath({field})).stringValue(),{pattern})))
[condition][]it is not true that_the {field} is Prohibited=(!((new Prohibited()).isProhibited((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_virtualSegmentCount {var0} =(!(virtualSegmentCount({var0})))
[condition][]it is not true that_segmentValueEquals {var0} {var1} {var2} =(!((new Equals()).segmentValueEquals({var0},{var1},{var2})))
[condition][]the {field} has_specified {segmentNumber} not equal to space=((new DatatypeCheck()).segmentNotEqualToSpace((xcb.xpath({field})).stringValue(),{segmentNumber}))
[condition][]it is not true that_valueOfFieldIsEqualToccurenceOfAnotherField {var0} {var1} =(!((new Occurence()).valueOfFieldIsEqualToccurenceOfAnotherField({var0},{var1})))
[condition][]the {field} is Alpha with Special Characters Set {setofspecialcharacters}=((new DatatypeCheck()).checkAlphaSPSet((xcb.xpath({field})).stringValue(),{setofspecialcharacters}))
[condition][]the {field} has_all uppercase characters=((new CapitalLetterCheck()).isAllUpperCase((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {fieldwithxpath} is prohibited=(!((new Prohibited()).isProhibited((xcb.xpath({fieldwithxpath})).stringValue())))
[condition][]the {field} has_from the start position {pos} to end position {pos} the constant {constant} followed by a Dot and followed by {number} alphanumeric characters=((new DatatypeCheck()).constantFollowedByDotFollowedByAlphaNumeric((xcb.xpath({field})).stringValue(),{pos},{pos},{constant},{number}))
[condition][]there is no {section} section=((new Populated()).isNotPopulatedSection({section}))
[condition][]the {fielddate1} is a Weekend=((new DateCheck()).isHoliday((xcb.xpath({fielddate1})).stringValue()))
[condition][]the interval between {fielddate1} and {fielddate2} is equal to {days}=((new DateCheck()).intervalBetweenTwoDateIsEqualtoDays((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue(),{days}))
[condition][]it is not true that_the {field} contains {CommaSeparatedValues}=(!((new Contains()).contains((xcb.xpath({field})).stringValue(),{CommaSeparatedValues})))
[condition][]routing matrix value check when any ALL is present{section}{subsect}{field}=(virtualRoutingMatrixCheck1({section},{subsect},(xcb.xpath({field})).stringValue()))
[condition][]it is not true that_anyOccurenceSection{sect}WithTag1{tag1}NotpopulatedAndTag2{tag2}Populatedwith errorcode{errorcode}=(!(virtualanyOccurenceWithTag1NotpopulatedAndTag2Populated({sect},{tag1},{tag2},{errorcode})))
[condition][]the order is a resend order=((new SuplementOrderCheck()).resendOrderCheck())
[condition][]the {field} has_the segment with specified {segnum} whose length is greater than specified {length} to support virgule or period=((new LengthCheck()).virguleandPeriodSegmentNumberLengthGreaterThan((xcb.xpath({field})).stringValue(),{segnum},{length}))
[condition][]atleast one occurence of{section} is populated=(virtualsaliAtleastOneOccurenceSectionPopulated1({section}))
[condition][]the {field} is Numeric without Special Characters Set {setofspecialcharacters}=((new DatatypeCheck()).checkNumericWithOutSPSet((xcb.xpath({field})).stringValue(),{setofspecialcharacters}))
[condition][]noconfirmationOrderCheck pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}=((new SuplementOrderCheck()).noConfirmationOrderCheck({pon},{ver},{ccna},{icsc},{description}))
[condition][]it is not true that_the field {field} with space in range {start} and {end}=(!((new SpaceCheck()).existenceOfSpaceInSpecRange((xcb.xpath({field})).stringValue(),{start},{end})))
[condition][]it is not true that_the {fieldvalue} is present in NCI table =(!((new ASOGTABLE()).fetchAbbreviationNCITable((xcb.xpath({fieldvalue})).stringValue())))
[condition][]the {field} is in the range A1 to Z99=((new RangeOfValues()).rangeCheckA1_Z99((xcb.xpath({field})).stringValue()))
[condition][]the value of {field1withxpath} is equal to number of occurance of {field2withxpath}=((new Occurence()).tagValueOfOneFieldEqualToNoOfOccurenceOfAnotherField((xcb.xpath({field1withxpath})).stringValue(),(xcb.xpath({field2withxpath})).stringValue()))
[condition][]the range of the {field} is A0 to Z9=((new RangeOfValues()).rangeCheckA0_Z9((xcb.xpath({field})).stringValue()))
[condition][]confirmationOrderCheckDes pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}=((new SuplementOrderCheck()).confirmationOrderCheckDes({pon},{ver},{ccna},{icsc},{description}))
[condition][]it is not true that_the {field} is not Required=(!((new Required()).isNotRequired((xcb.xpath({field})).stringValue())))
[condition][]the version {VER} is not one greater than the previous database version for the pon {PON} ccna {CCNA} and icsc {ICSC} with status {status}=((new SuplementOrderCheck()).verNotOneGreaterThanLatestDBVersion({VER},{PON},{CCNA},{ICSC},{status}))
[condition][]the {field} has_specified segment {segnum} which contains alpha numeric characters with space=((new DatatypeCheck()).segmentEqualToAlphaNumericWithSpace((xcb.xpath({field})).stringValue(),{segnum}))
[condition][]it is not true that_the field {tagValue} is populated as per specified TLV format from positions 1 12 =(!((new Position()).formatCheckForFields1_12({tagValue})))
[condition][]the substring after colon of the {field} equals {values}=((new SvcType()).compareSvcTypeAfterColon((xcb.xpath({field})).stringValue(),{values}))
[condition][]it is not true that_the {field} from positions {pos1} to {pos2} is populated or not spaces=(!((new Populated()).rangeOfPositionIsPopulatedOrNotSpaces((xcb.xpath({field})).stringValue(),{pos1},{pos2})))
[condition][]any occurence of{fieldwithxpath} is not populated=((new Occurence()).anyOccurenceOfFieldNotPopulated((xcb.xpath({fieldwithxpath})).stringValue()))
[condition][]it is not true that_the {field} has_three consecutive uppercase alphabets=(!((new CapitalLetterCheck()).threeConsecutiveUpperCaseAlpha((xcb.xpath({field})).stringValue())))
[condition][]the {fieldvalue} is present in NC table =((new ASOGTABLE()).fetchAbbreviationNCTable((xcb.xpath({fieldvalue})).stringValue()))
[condition][]it is not true that_the {field} has_all lowercase characters for comma seperated values=(!((new CapitalLetterCheck()).isAllLowerCaseForCSV((xcb.xpath({field})).stringValue())))
[condition][]all tags of unimapping {section} in current and previous version check {sup} {pon} {ver} {ccna} {icsc} {uact} {values} {uref} with {code}=((new Occurence()).VirtualUnimappingTagsCheckWIthPreviousVer({section},{sup},{pon},{ver},{ccna},{icsc},{uact},{values},{uref},{code}))
[condition][]cktActCheckWithPrevVer {var0} {var1} {var2} {var3} {var4} {var5} {var6} =((new SuplementOrderCheck()).cktActCheckWithPrevVer({var0},{var1},{var2},{var3},{var4},{var5},{var6}))
[condition][]it is not true that_Request PON{pon} VER{ver} CCNA{ccna} ICSC{icsc} exists in DB=(!((new SuplementOrderCheck()).checkRequestExistsInDatabase({pon},{ver},{ccna},{icsc})))
[condition][]allLowerCase {var0} =((new CapitalLetterCheck()).allLowerCase({var0}))
[condition][]the {field} has_telephone number format as {tnformat}=((new TNFormat()).tnFormatIs((xcb.xpath({field})).stringValue(),{tnformat}))
[condition][]numericCheckFormat {var0} {var1} {var2} =((new SpecialFormat()).NumericCheckFormat({var0},{var1},{var2}))
[condition][]the {field} has_date format as {format}=((new DateFormatCheck()).dateCheck((xcb.xpath({field})).stringValue(),{format}))
[condition][]it is not true that_the field {fieldname} with parent section {parentname} is populated in previous version for the pon {PON} ver {VER} ccna {CCNA} and icsc {ICSC}=(!((new SuplementOrderCheck()).fieldPopulatedInPreviousVersion((xcb.xpath({fieldname})).stringValue(),{parentname},{PON},{VER},{CCNA},{ICSC})))
[condition][]isCurrentDateLessThanOrEqualToDesiredDueDate {var0} =((new DateCheck()).isCurrentDateLessThanOrEqualToDesiredDueDate({var0}))
[condition][]it is not true that_the {field} has_not a valid values {commaseperatedvalues}=(!((new isValidValue()).isNotValidValues((xcb.xpath({field})).stringValue(),{commaseperatedvalues})))
[condition][]it is not true that_setICSCLicense {var0} =(!((new SvcType()).setICSCLicense({var0})))
[condition][]it is not true that_the {field} is populated with {numberofsegment} segments=(!((new LengthCheck()).numberOfSegments((xcb.xpath({field})).stringValue(),{numberofsegment})))
[condition][]noOfOccurence {var0} =((new Occurence()).noOfOccurence({var0}))
[condition][]the range of the {field} is AA to ZZ=((new RangeOfValues()).rangeCheckAA_ZZ((xcb.xpath({field})).stringValue()))
[condition][]the occurance of {fieldwithxpath} is less than {number}=((new Occurence()).noOfOccurenceLessThan((xcb.xpath({fieldwithxpath})).stringValue(),{number}))
[condition][]it is not true that_the {field} has_comma seperated values=(!((new CommaSeparatedSpace()).checkCommaSeparatedSpace((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_anyARIPrilocAndPrilocSpotCheck {var0} {var1} {var2} =(!((new Occurence()).anyARIPrilocAndPrilocSpotCheck({var0},{var1},{var2})))
[condition][]isRequired {var0} =((new Required()).isRequired({var0}))
[condition][]it is not true that_all occurences of {section} of field {field} equals the value{value} with errorcode {errorcode}=(!(virtualAllOccurenceOfFieldEqualsValue({section},(xcb.xpath({field})).stringValue(),{value},{errorcode})))
[condition][]it is not true that_the icsc {fieldvalue} has_the license for the table {NCNCIICSCCLLI}=(!((new ASOGTABLE()).checkIcscLicenseForTable((xcb.xpath({fieldvalue})).stringValue(),{NCNCIICSCCLLI})))
[condition][]it is not true that_number of occurences{fieldwithxpath} equals{value}=(!((new Occurence()).noOfOccurenceEqualsValue((xcb.xpath({fieldwithxpath})).stringValue(),{value})))
[condition][]it is not true that_tagValue {var0} =(!((new Occurence()).tagValue({var0})))
[condition][]it is not true that_the {pos} position_of {field} is in range {startvalue} and {endvalue}=(!((new Populated()).isPostionOfFieldPopulatedInRange({pos},(xcb.xpath({field})).stringValue(),{startvalue},{endvalue})))
[condition][]{xpath} is unique=((new Unique()).isUnique({xpath}))
[condition][]any one of the segment that may be delimeted by the char {delimchar} of the {field} does not contain {Alpha} Alpha character followed by maximum number {num} of numeric characters=((new LengthCheck()).segmentDoesNotContainsAlphaCountFollowedByNumericCount({delimchar},(xcb.xpath({field})).stringValue(),{Alpha},{num}))
[condition][]it is not true that_the order is a resend order=(!((new SuplementOrderCheck()).resendOrderCheck()))
[condition][]it is not true that_the CKTACT field check pon{pon} ver{ver} ccna{ccna} icsc{icsc} and xpath{xpath} tag{tag} with value{value} for rule{ruleErrorCode}=(!((new Occurence()).cktActCheck({pon},{ver},{ccna},{icsc},{xpath},{tag},{value},{ruleErrorCode})))
[condition][]tag value of the request order for the pon{pon} ver{ver} ccna{ccna} icsc{icsc} section{section} tag{tag} not equals {value}=((new SuplementOrderCheck()).requestDoesNothaveTheTagValue({pon},{ver},{ccna},{icsc},{section},{tag},{value}))
[condition][]it is not true that_AnyOccoffield1withsection{multiecoec} field1 {OECICSC}equals field2{field2} with values {value1} and {value2} with errorCode {errorcode}=(!(virtualAnyOccoffield1equalsvaluewherefield2notequalsvalue({multiecoec},{OECICSC},(xcb.xpath({field2})).stringValue(),{value1},{value2},{errorcode})))
[condition][]it is not true that_the occurance of {fieldwithxpath} is less than {number}=(!((new Occurence()).noOfOccurenceLessThan((xcb.xpath({fieldwithxpath})).stringValue(),{number})))
[condition][]anyOccurenceSection{sect}WithTag1{tag1}NotpopulatedAndTag2{tag2}Populatedwith errorcode{errorcode}=(virtualanyOccurenceWithTag1NotpopulatedAndTag2Populated({sect},{tag1},{tag2},{errorcode}))
[condition][]the {field} contains numeric values followed by lowercase Alpha Characters=((new CapitalLetterCheck()).fieldContainsNumericValuesFollowedByLowercaseAlphaCharacters((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} from {pos1} to {pos2} of the segment{segnum} has_the comma seperated values{values} to support virgule or period as delimiter=(!((new LengthCheck()).virguleandPeriodPosToPosOfSegmentNotEquals((xcb.xpath({field})).stringValue(),{pos1},{pos2},{segnum},{values})))
[condition][]it is not true that_the{section}{field} lengths not equals{value} with code {code}=(!(virtualResponseLengthCheck({section},(xcb.xpath({field})).stringValue(),{value},{code})))
[condition][]the {field} has_all lowercase characters=((new CapitalLetterCheck()).isAllLowerCase((xcb.xpath({field})).stringValue()))
[condition][]the {fieldvalue} is present in the LOCATION table=((new ASOGTABLE()).fetchAbbreviationLOCATIONTable((xcb.xpath({fieldvalue})).stringValue()))
[condition][]it is not true that_virtualoccurenceofuactNCIRuid {vector} {list} {ncivalue} {errorcode} =(!(virtualoccurenceofuactNCIRuid({vector},{list},{ncivalue},{errorcode})))
[condition][]it is not true that_the {field} is AlphaNumeric=(!((new DatatypeCheck()).checkAlphaNumeric((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {field} is Numeric with Special Characters Set {setofspecialcharacters}=(!((new DatatypeCheck()).checkNumericSPSet((xcb.xpath({field})).stringValue(),{setofspecialcharacters})))
[condition][]the_length_of {field} is between {min} and {max} values=((new LengthCheck()).checkMinMaxLength((xcb.xpath({field})).stringValue(),{min},{max}))
[condition][]the field value {fieldvalue} matches the pattern {pattern}=((new SpecialFormat()).isPatternMatches((xcb.xpath({fieldvalue})).stringValue(),{pattern}))
[condition][]characterFollowedBySpace {var0} {var1} =((new Contains()).characterFollowedBySpace({var0},{var1}))
[condition][]the fields NC {NC} NCI {NCI} and SECNCI {SECNCI} are not compatible with database=((new ASOGTABLE()).checkNcNciCompatibility({NC},{NCI},{SECNCI}))
[condition][]the difference between {fielddate1} and {fielddate2} is not equal to one year=((new DateCheck()).isRangeNotEqualToOneYear((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue()))
[condition][]it is not true that_the {field} from positions {pos1} to {pos2} is not populated or spaces=(!((new Populated()).rangeOfPositionIsNotPopulatedOrSpaces((xcb.xpath({field})).stringValue(),{pos1},{pos2})))
[condition][]it is not true that_The {field} contains whitespaces or numbers in range or zeros from second position_to end=(!((new Position()).charAtPositionCheck((xcb.xpath({field})).stringValue())))
[condition][]setNCILicense {var0} =((new SvcType()).setNCILicense({var0}))
[condition][]the {field} is AlphaNumeric with following Special Character set {setofspecialcharacters}=((new DatatypeCheck()).checkAlphaNumericSPSet((xcb.xpath({field})).stringValue(),{setofspecialcharacters}))
[condition][]it is not true that_tagValueEqualsInPreviousVersion {var0} {var1} {var2} {var3} {var4} {var5} {var6} =(!((new SuplementOrderCheck()).tagValueEqualsInPreviousVersion({var0},{var1},{var2},{var3},{var4},{var5},{var6})))
[condition][]it is not true that_the {field} has_none valid values {commaseperatedvalues}=(!((new isValidValue()).isNoneValidValues((xcb.xpath({field})).stringValue(),{commaseperatedvalues})))
[condition][]it is not true that_Is the {field} of the specified segment {segnum} is in the range 00 999=(!((new RangeOfValues()).segmentRangeCheck00_999((xcb.xpath({field})).stringValue(),{segnum})))
[condition][]it is not true that_the {pos} and {pos} position_of the {field} is lesser than or equal to {pos} and {pos} position=(!((new Position()).twoPositionValueofTagIsLessThanOrEqualToTheValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos})))
[condition][]it is not true that_any occurence of field{section}{field} is not populated and assosiated tag{tag} equals {values} and corresponding tag{tag} equals {values}=(!(virtualAnyOccurenceOfFieldNotPopulatedAndAssosiatedTagEqualsValuesAndCorrespondingTagEqualsValues({section},(xcb.xpath({field})).stringValue(),{tag},{values},{tag},{values})))
[condition][]the interval duration is blank for the {nc}=((new IntervalDurationMatcher()).isIntervalExisting({nc}))
[condition][]it is not true that_virtualoccOfF1nF2andVAL1nVAL2withinsameUNIMAPPING {section} {errorcode} {field1} {F1values} {field2} {F2values} {field3} =(!(virtualoccOfF1nF2andVAL1nVAL2withinsameUNIMAPPING({section},{errorcode},(xcb.xpath({field1})).stringValue(),{F1values},(xcb.xpath({field2})).stringValue(),{F2values},(xcb.xpath({field3})).stringValue())))
[condition][]the {field} has_no values{commaseperatedvalues} in the segment{segnum} to support virgule or period as delimiter=((new Equals()).virguleandPeriodSegmentValueNotEqualToValues((xcb.xpath({field})).stringValue(),{commaseperatedvalues},{segnum}))
[condition][]it is not true that_the CCNA has_license for NCNCICOMPATIBILITY Table=(!((new SvcType()).getNCNCICompatibilityLicense()))
[condition][]the {field} contains alpha characters=((new Contains()).containsAlpha((xcb.xpath({field})).stringValue()))
[condition][]the {field}is not_equal_to_values {CommaSeparatedValues}=((new Equals()).isNotEqualToValues((xcb.xpath({field})).stringValue(),{CommaSeparatedValues}))
[condition][]anyOccurenceOfFieldPopulatedAndAssosiatedTagNotEqualsValues {var0} {var1} {var2} {var3} {var4} =((new Occurence()).anyOccurenceOfFieldPopulatedAndAssosiatedTagNotEqualsValues({var0},{var1},{var2},{var3},{var4}))
[condition][]the_section{section} with the field {field} is not consecutively assigned from value{value} with errorcode {errorcode}=(virtualFieldIsNotConsecutivelyAssignedAcrossOccurrences({section},(xcb.xpath({field})).stringValue(),{value},{errorcode}))
[condition][]it is not true that_the value of {field} not equals the occurences of{section}{subsectn}=(!(virtualsaliValueOfFieldNotEqualsOccurenceOfOtherSection((xcb.xpath({field})).stringValue(),{section},{subsectn})))
[condition][]the pos1{pos1} to pos2{pos2} of the field{fieldvalue} not in range {startvalue} to {endvalue}=((new RangeOfValues()).checkPos1ToPos2ValueNotInRange({pos1},{pos2},(xcb.xpath({fieldvalue})).stringValue(),{startvalue},{endvalue}))
[condition][]the difference between {fielddate1} and {fielddate2} is less than or equal to one year=((new DateCheck()).isRangeLesserThanOrEqualToOneYear((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue()))
[condition][]segact of ARI{ari} {segact} and RING{ring} value check with errorcode {errorcode}=(virtualSegactValueCheck({ari},{segact},{ring},{errorcode}))
[condition][]any occurrence of servpref {section}{subsect} populated=(virtualAnyOccurenceOfServPrefPopulated({section},{subsect}))
[condition][]the {segnum} segment of the {fieldvalue} is present in the LOCATION Table=(virtualSegmentFetchAbbreviationLOCATIONTable({segnum},(xcb.xpath({fieldvalue})).stringValue()))
[condition][]it is not true that_ccnaMultiEcIcscCheck {var0} {var1} {var2} =(!((new SuplementOrderCheck()).ccnaMultiEcIcscCheck({var0},{var1},{var2})))
[condition][]it is not true that_the {field} contains numeric characters=(!((new Contains()).containsNumeric((xcb.xpath({field})).stringValue())))
[condition][]virtualoccurenceofVACTandUACT {section} {errorcode} =(virtualoccurenceofVACTandUACT({section},{errorcode}))
[condition][]the pos{pos1} to {pos2} of the field {field} with specified segment {segnum} is equal to the pos{pos1} to {pos2} of another field {field}=((new Position()).segmentInPositionRangeEqualToNextFieldSpecifiedPositionRange({pos1},{pos2},(xcb.xpath({field})).stringValue(),{segnum},{pos1},{pos2},(xcb.xpath({field})).stringValue()))
[condition][]the {field} has_three consecutive uppercase alphabets=((new CapitalLetterCheck()).threeConsecutiveUpperCaseAlpha((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {fielddate1} is not equal to {fielddate2}=(!((new DateCheck()).isNotEqualTo((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue())))
[condition][]it is not true that   new SvcType  getSvcName  =(!((new SvcType()).getSvcName()))
[condition][]confirmationOrderCheck pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}=((new SuplementOrderCheck()).confirmationOrderCheck({pon},{ver},{ccna},{icsc},{description}))
[condition][]it is not true that_the{section}{field}is populated and assosiated tag{tag} not equals to values{values}=(!(virtualAnyOccurenceOfFieldPopulatedAndAssosiatedTagNotEqualsValues({section},(xcb.xpath({field})).stringValue(),{tag},{values})))
[condition][]the {sectn} has_the naickt{naiSectn} for the cancelled refnum{field} with value{value}=(virtualAnyNAICKTcheckForCancelledUREF({sectn},{naiSectn},(xcb.xpath({field})).stringValue(),{value}))
[condition][]the interval between {fielddate1} and {fielddate2} is less than {days}=((new DateCheck()).intervalBetweenTwoDateIsLessThanDays((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue(),{days}))
[condition][]virtualuactValueCheckWithPreviousVersion {section} {sup} {pon} {ver} {ccna} {icsc} {uact} {value} {uref} with {code} =((new Occurence()).VirtualUactValueCheckWithPreviousVersion({section},{sup},{pon},{ver},{ccna},{icsc},{uact},{value},{uref},{code}))
[condition][]the {field} has_specified range {start} to {end}=((new RangeOfValues()).rangeCheckNN_NN((xcb.xpath({field})).stringValue(),{start},{end}))
[condition][]the {fielddate1} is a working day=((new DateCheck()).isWorkingDay((xcb.xpath({fielddate1})).stringValue()))
[condition][]the {field} is AlphaNumeric with Special Characters=((new DatatypeCheck()).checkAlphaNumericSP((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} has_specified segment {segnum} which contains alpha numeric characters with space=(!((new DatatypeCheck()).segmentEqualToAlphaNumericWithSpace((xcb.xpath({field})).stringValue(),{segnum})))
[condition][]the field differs from previous version tag value for the pon {PON} version {VER} icsc{ICSC} and ccna{CCNA} {fieldname} of {parentname} at pos{POS} with field {fieldvalue}=((new SuplementOrderCheck()).tagValueDiffersInPreviousVersionatspecpos({PON},{VER},{ICSC},{CCNA},(xcb.xpath({fieldname})).stringValue(),{parentname},{POS},(xcb.xpath({fieldvalue})).stringValue()))
[condition][]it is not true that_The number of occurence of {path} populated is greater than {number}=(!((new Occurence()).NumberOfoccurencepopulatedisgreaterthan({path},{number})))
[condition][]checkResponsePonDoesNotExistInRequest {var0} {var1} {var2} =((new SuplementOrderCheck()).checkResponsePonDoesNotExistInRequest({var0},{var1},{var2}))
[condition][]it is not true that_virtualuactValueCheckWithPreviousVersion {section} {sup} {pon} {ver} {ccna} {icsc} {uact} {value} {uref} with {code} =(!((new Occurence()).VirtualUactValueCheckWithPreviousVersion({section},{sup},{pon},{ver},{ccna},{icsc},{uact},{value},{uref},{code})))
[condition][]checkAnyPositionsInRangeContainsValues {var0} {var1} {var2} {var3} =((new Position()).checkAnyPositionsInRangeContainsValues({var0},{var1},{var2},{var3}))
[condition][]the_section{section} parent{parent} tag {tag} does not have value{value} in any occurence=(virtualNoneOccurenceEqualsValue({section},{parent},{tag},{value}))
[condition][]it is not true that_isCurrentDateLessThanOrEqualToDesiredDueDate {var0} =(!((new DateCheck()).isCurrentDateLessThanOrEqualToDesiredDueDate({var0})))
[condition][]the {field} is_equal_to_values {CommaSeparatedValues}=((new Equals()).isEqualToValues((xcb.xpath({field})).stringValue(),{CommaSeparatedValues}))
[condition][]the {field} has_AND which is preceeded and followed by space=((new SpaceCheck()).isAndPrecFollSpace((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {pos} position_of {field} is not equal to {value}=(!(virtualPositionOftagValueNotEqualToValue({pos},(xcb.xpath({field})).stringValue(),{value})))
[condition][]it is not true that_confirmationOrderCheck {var0} {var1} {var2} {var3} =(!((new SuplementOrderCheck()).confirmationOrderCheck({var0},{var1},{var2},{var3})))
[condition][]routing matrix value check{section}{subsect}{field}=(virtualRoutingMatrixCheck({section},{subsect},(xcb.xpath({field})).stringValue()))
[condition][]it is not true that_routing matrix 1 value check when any ALL is present{section}{subsect}{field}=(!((new Occurence()).routingMatrixCheck1({section},{subsect},(xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {fielddate1} is a working day=(!((new DateCheck()).isWorkingDay((xcb.xpath({fielddate1})).stringValue())))
[condition][]it is not true that_any occurence of {section}{field} is not populated with {errorcode}=(!((new Occurence()).VirtualAnyOccurenceIsNotPopulated({section},(xcb.xpath({field})).stringValue(),{errorcode})))
[condition][]the CCNA has_license for NCI Table=((new SvcType()).getNCILicense())
[condition][]it is not true that_the {field} is AlphaNumeric without following Special Character set {setofspecialcharacters}=(!((new DatatypeCheck()).checkAlphaNumericWithOutSPSet((xcb.xpath({field})).stringValue(),{setofspecialcharacters})))
[condition][]it is not true that_for the Trading Partner with the ICSC {icscvalue} the {datevalue} falls on holiday=(!((new HOLIDAY()).fetchTPHoliday({icscvalue},{datevalue})))
[condition][]firstPositionRangeGreaterThanSecondPositionRange {var0} {var1} {var2} {var3} {var4} =((new Position()).firstPositionRangeGreaterThanSecondPositionRange({var0},{var1},{var2},{var3},{var4}))
[condition][]it is not true that_virtualoccurenceofVACTandUACT3CEVLAN {var0} {var1} =(!(virtualoccurenceofVACTandUACT3CEVLAN({var0},{var1})))
[condition][]atleast one occurence of{section}{subsectn} is populated=(virtualsaliAtleastOneOccurenceSectionPopulated({section},{subsectn}))
[condition][]it is not true that_the pos {pos} to {pos} of segment {segnum} of the field {field} does not_equal_to_values {commaseparatedvalues}=(!((new LengthCheck()).posToPosOfSegmentNotEquals({pos},{pos},{segnum},(xcb.xpath({field})).stringValue(),{commaseparatedvalues})))
[condition][]the position_of Alpha is {pos} in {field}=((new DatatypeCheck()).checkPositionAlpha({pos},(xcb.xpath({field})).stringValue()))
[condition][]spaceOrCharacterOrNumberInRange01_99 {var0} {var1} {var2} {var3} {var4} =((new Position()).spaceOrCharacterOrNumberInRange01_99({var0},{var1},{var2},{var3},{var4}))
[condition][]it is not true that_the {field} is Numeric with Special Characters=(!((new DatatypeCheck()).checkNumericSP((xcb.xpath({field})).stringValue())))
[condition][]the difference between {fielddate1} and {fielddate2} is greater than specified {fieldmonths}=((new DateCheck()).isRangeGreaterThanSpecifiedMonths((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue(),(xcb.xpath({fieldmonths})).stringValue()))
[condition][]it is not true that_the {fieldwithxpath} occurance is atleast {numberoftimes}=(!((new Occurence()).atleastOccurenceOf((xcb.xpath({fieldwithxpath})).stringValue(),{numberoftimes})))
[condition][]the interval between {fielddate1} and {fielddate2} is greater than {days}=((new DateCheck()).intervalBetweenTwoDateIsGreaterThanDays((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue(),{days}))
[condition][]the {field} has_comma seperated values=((new CommaSeparatedSpace()).checkCommaSeparatedSpace((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_virtualoccurenceofSvlanMppingfortwoocc {Vector} {errorcode} =(!(virtualoccurenceofSvlanMppingfortwoocc({Vector},{errorcode})))
[condition][]the {field} has_format as {format}=((new SpecialFormat()).formatIs((xcb.xpath({field})).stringValue(),{format}))
[condition][]it is not true that_virguleFollowedByVirgule {var0} =(!((new Contains()).virguleFollowedByVirgule({var0})))
[condition][]it is not true that_tag value of the request order for the pon{pon} ver{ver} ccna{ccna} icsc{icsc} section{section} tag{tag} not equals {value}=(!((new SuplementOrderCheck()).requestDoesNothaveTheTagValue({pon},{ver},{ccna},{icsc},{section},{tag},{value})))
[condition][]the {field} has_all lowercase characters for comma seperated values=((new CapitalLetterCheck()).isAllLowerCaseForCSV((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the segment {segnum} length of the field {fieldvalue} is in the range {min} and {max}=(!(virtualSegmentNumberLengthInRange({segnum},(xcb.xpath({fieldvalue})).stringValue(),{min},{max})))
[condition][]virguleFollowedByVirgule {var0} =((new Contains()).virguleFollowedByVirgule({var0}))
[condition][]the field differs from previous version for the pon {PON} version {VER} icsc{ICSC} and ccna{CCNA} {fieldname} of {parentname} at pos{POS} with fieldvalue {fieldvalue}=((new SuplementOrderCheck()).fieldDiffersFromPreviousVersionatspecpos({PON},{VER},{ICSC},{CCNA},(xcb.xpath({fieldname})).stringValue(),{parentname},{POS},(xcb.xpath({fieldvalue})).stringValue()))
[condition][]it is not true that_the {field} has_the specified {value} in the range {start} to {end}=(!((new RangeOfValues()).compareSpecStringInRange((xcb.xpath({field})).stringValue(),{value},{start},{end})))
[condition][]it is not true that_virtualoccOfVPNIDnSVLANSTARTwithinsameUNIMAPPING {section} {errorcode} =(!(virtualoccOfVPNIDnSVLANSTARTwithinsameUNIMAPPING({section},{errorcode})))
[condition][]the {field} is numeric with trailing spaces=((new DatatypeCheck()).checkNumericWithTrailingSPacesOnly((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} has_a space which is followed by numeric=(!((new SpaceCheck()).spaceFollowedByNumeric((xcb.xpath({field})).stringValue())))
[condition][]containsSpaceInSpecRange {var0} {var1} {var2} =((new Contains()).containsSpaceInSpecRange({var0},{var1},{var2}))
[condition][]setNCLicense {var0} =((new SvcType()).setNCLicense({var0}))
[condition][]the {field} is compared with the specified positions {pos1} to {pos2} with values {value1} or {value2}=((new Position()).compareCharAtAnyPositionWithAnyValue((xcb.xpath({field})).stringValue(),{pos1},{pos2},{value1},{value2}))
[condition][]it is not true that_the {field} contains {num} of spaces before Alpha Characters=(!((new CapitalLetterCheck()).containsConsecutiveSpacesBeforeAlphaCharacters((xcb.xpath({field})).stringValue(),{num})))
[condition][]the ICSC has_license for NCNCICOMPATIBILITY Table=((new SvcType()).getIcscCLLILicense())
[condition][]it is not true that_timeRange {var0} {var1} {var2} =(!((new TimeFormatCheck()).timeRange({var0},{var1},{var2})))
[condition][]the icsc {fieldvalue} has_the license for the table {NCNCIICSCCLLI}=((new ASOGTABLE()).checkIcscLicenseForTable((xcb.xpath({fieldvalue})).stringValue(),{NCNCIICSCCLLI}))
[condition][]it is not true that_the table {tablename} does not exists in the data base=(!((new ASOGTABLE()).checkNonExistenceOfTable({tablename})))
[condition][]Is the {field} of the specified segment {segnum} is in the range 00 999=((new RangeOfValues()).segmentRangeCheck00_999((xcb.xpath({field})).stringValue(),{segnum}))
[condition][]it is not true that_the {pos} position_Of {field} equal to {value}=(!((new Contains()).positionOfFieldEqualToValue({pos},(xcb.xpath({field})).stringValue(),{value})))
[condition][]it is not true that_the field {field1} is greater than field {field2}=(!((new Equals()).field1IsGreaterThanField2((xcb.xpath({field1})).stringValue(),(xcb.xpath({field2})).stringValue())))
[condition][]it is not true that_the last character Of {field} is {value}=(!((new Equals()).lastCharacterOfField((xcb.xpath({field})).stringValue(),{value})))
[condition][]it is not true that_the_section EVC {section} with sub section {subsect} for the field {field} is not conecutively assigned starting with {value} then errorcode {errorcode}=(!(virtuallrefIsNotConecutivelyAssignedStratingWIthValue({section},{subsect},(xcb.xpath({field})).stringValue(),{value},{errorcode})))
[condition][]the {field} is greater than {value}=((new Equals()).isGreaterThan((xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_the {pos} and {pos} position_of the {field} is not equal to {pos} and {pos} position=(!((new Position()).twoPositionValueofTagNotEqualToValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos})))
[condition][]it is not true that_the {fielddate1} is greater than or equal to {fielddate2}=(!((new DateCheck()).isGreaterThanOrEqualTo((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue())))
[condition][]the {field} has_alpha characters in the specified range {start} to {end}=((new RangeOfValues()).numberOfAlphaInSpecRange((xcb.xpath({field})).stringValue(),{start},{end}))
[condition][]it is not true that_the {field} contains atleast one non space character in the range {start} to {end}=(!((new SpaceCheck()).checkAtleastOneNonSpaceInRange((xcb.xpath({field})).stringValue(),{start},{end})))
[condition][]it is not true that_the value of {field} not equals the occurences of{section}=(!(virtualsaliValueOfFieldNotEqualsOccurenceOfOtherSection1((xcb.xpath({field})).stringValue(),{section})))
[condition][]it is not true that_the {field} is greater than {value}=(!((new Equals()).isGreaterThan((xcb.xpath({field})).stringValue(),{value})))
[condition][]Request PON{pon} VER{ver} CCNA{ccna} ICSC{icsc} exists in DB=((new SuplementOrderCheck()).checkRequestExistsInDatabase({pon},{ver},{ccna},{icsc}))
[condition][]it is not true that_the each position_from {pos1} to {pos2} of {field} is not_equal_to_values{commaseperatedvalues}=(!((new Position()).checkEachPositionsInRangeNotEqualToValues({pos1},{pos2},(xcb.xpath({field})).stringValue(),{commaseperatedvalues})))
[condition][]the interval between {fielddate1} and {fielddate2} is not equal to {days}=((new DateCheck()).intervalBetweenTwoDateIsNotEqualtoDays((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue(),{days}))
[condition][]fieldPositionInRange {var0} {var1} {var2} {var3} =((new RangeOfValues()).fieldPositionInRange({var0},{var1},{var2},{var3}))
[condition][]the {field} from positions {pos1} to {pos2} is not populated and not spaces=((new Populated()).rangeOfPositionIsNotPopulatedAndNotSpaces((xcb.xpath({field})).stringValue(),{pos1},{pos2}))
[condition][]the {field} has_segment with specified {segnum} of the specified {length} to support virgule or period=((new LengthCheck()).virguleandPeriodSegmentNumberLengthEqualTo((xcb.xpath({field})).stringValue(),{segnum},{length}))
[condition][]it is not true that_setNCILicense {var0} =(!((new SvcType()).setNCILicense({var0})))
[condition][]the{section} {field} is not unique in all the occurences with code {code}=((new Occurence()).isUnique({section},(xcb.xpath({field})).stringValue(),{code}))
[condition][]it is not true that_virtualoccOfF1POPnF2NOTPOPwithinsameUNIMAPPING {section} {errorcode} {field1} {field2} {field3} =(!(virtualoccOfF1POPnF2NOTPOPwithinsameUNIMAPPING({section},{errorcode},(xcb.xpath({field1})).stringValue(),(xcb.xpath({field2})).stringValue(),(xcb.xpath({field3})).stringValue())))
[condition][]Is the {field} of the specified {segnum} according to the format {format}=((new DateFormatCheck()).isSpecifiedSegmentInValidFormat((xcb.xpath({field})).stringValue(),{segnum},{format}))
[condition][]it is not true that_the multiple field{field} has_length greater than{value} in any occurence=(!((new Occurence()).lengthCheckForMultipleOccuringTag((xcb.xpath({field})).stringValue(),{value})))
[condition][]Check for reqtyp{field} pon{field}ver{ver}ccna{ccna}icsc{icsc}=((new SuplementOrderCheck()).reqtypFieldCheck((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),{ver},{ccna},{icsc}))
[condition][]positionOfStringInSpecifiedRange {var0} {var1} {var2} {var3} =((new RangeOfValues()).PositionOfStringInSpecifiedRange({var0},{var1},{var2},{var3}))
[condition][]it is not true that_set the activity of to {var0}=(!((new ReqTypeAct()).setActivity({var0})))
[condition][]it is not true that_the field value {fieldvalue} do_not_matches the pattern {pattern}=(!((new SpecialFormat()).isPatternNotMatches((xcb.xpath({fieldvalue})).stringValue(),{pattern})))
[condition][]virtualoccOfVPNIDnSVLANSTARTnASNwithinsameUNIMAPPING {section} {errorcode} =(virtualoccOfVPNIDnSVLANSTARTnASNwithinsameUNIMAPPING({section},{errorcode}))
[condition][]any occurence of the {fieldwithxpath} is populated in Response=((new Occurence()).anyOccurenceOfFieldPopulatedInRespose((xcb.xpath({fieldwithxpath})).stringValue()))
[condition][]the {pos} and {pos} position_of the {field} is equal to {pos} and {pos} position=((new Position()).twoPositionValueofTagEqualToValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos}))
[condition][]it is not true that_anyOccurenceOfMultipleFieldIsPopulatedAndNotNumeric {var0} =(!((new Occurence()).anyOccurenceOfMultipleFieldIsPopulatedAndNotNumeric({var0})))
[condition][]lrefListFieldPopulatedAssoTagIsNotPopulatedOrCorrespondingTagNotEqualsVlaues {var0} {var1} {var2} {var3} {var4} {var5} {var6} =((new Occurence()).lrefListFieldPopulatedAssoTagIsNotPopulatedOrCorrespondingTagNotEqualsVlaues({var0},{var1},{var2},{var3},{var4},{var5},{var6}))
[condition][]the {pos} position_of {field} is in range {startvalue} and {endvalue}=((new Populated()).isPostionOfFieldPopulatedInRange({pos},(xcb.xpath({field})).stringValue(),{startvalue},{endvalue}))
[condition][]it is not true that_the pos1{pos1} to pos2{pos2} of the field{fieldvalue} not in range {startvalue} to {endvalue}=(!((new RangeOfValues()).checkPos1ToPos2ValueNotInRange({pos1},{pos2},(xcb.xpath({fieldvalue})).stringValue(),{startvalue},{endvalue})))
[condition][]it is not true that_the {field} is AlphaNumeric with only space as special character=(!((new DatatypeCheck()).checkAlphaNumericWithSpaceAsSpecialCharacter((xcb.xpath({field})).stringValue())))
[condition][]the {field} from {pos1} to {pos2} of the segment{segnum} has_the comma seperated values{values} to support virgule or period as delimiter=((new LengthCheck()).virguleandPeriodPosToPosOfSegmentNotEquals((xcb.xpath({field})).stringValue(),{pos1},{pos2},{segnum},{values}))
[condition][]the {field} is populated with {numberofsegment} segments=((new LengthCheck()).numberOfSegments((xcb.xpath({field})).stringValue(),{numberofsegment}))
[condition][]it is not true that_the {field} has_no values{commaseperatedvalues} in the segment{segnum} to support virgule or period as delimiter=(!((new Equals()).virguleandPeriodSegmentValueNotEqualToValues((xcb.xpath({field})).stringValue(),{commaseperatedvalues},{segnum})))
[condition][]it is not true that_CHECK FIRMORDER request{field} pon{field} ver{field} ccna{field} icsc{field}=(!((new SuplementOrderCheck()).firmOrderToServiceRequestCheck((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue())))
[condition][]the field {tagValue} is populated as per specified TLV format from positions 1 12 =((new Position()).formatCheckForFields1_12({tagValue}))
[condition][]the {field} is Prohibited for {commaseperatedvalues}=((new Prohibited()).prohibitedForValues((xcb.xpath({field})).stringValue(),{commaseperatedvalues}))
[condition][]it is not true that_the {field} is not populated=(!((new Populated()).isNotPopulated((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {field} has_specified segment {segnum} which has_the specified alpha {specAlpha}=(!((new DatatypeCheck()).segmentNotEqualToSpecifiedAlpha((xcb.xpath({field})).stringValue(),{segnum},{specAlpha})))
[condition][]it is not true that_the {fielddate1} is less than or equal to {fielddate2}=(!((new DateCheck()).isLessThanOrEqualTo((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue())))
[condition][]it is not true that_the each position_from {pos1} to {pos2} of {field} is not in between {startrange} and {endrange}=(!((new RangeOfValues()).checkPositionsInRangeNotPopulatedInRangeOfValues({pos1},{pos2},(xcb.xpath({field})).stringValue(),{startrange},{endrange})))
[condition][]it is not true that_the_length_of {field} is between {min} and {max} values=(!((new LengthCheck()).checkMinMaxLength((xcb.xpath({field})).stringValue(),{min},{max})))
[condition][]isCurrentDateLessThanOrNotEqualToDesiredDueDate {var0} =((new DateCheck()).isCurrentDateLessThanOrNotEqualToDesiredDueDate({var0}))
[condition][]it is not true that_setSvcName {var0} =(!((new SvcType()).setSvcName({var0})))
[condition][]the difference between {fielddate1} and {fielddate2} is greater than one year=((new DateCheck()).isRangeGreaterThanOneYear((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue()))
[condition][]it is not true that_the minimum length of {field} is {value}=(!((new LengthCheck()).checkMinimumLength((xcb.xpath({field})).stringValue(),{value})))
[condition][]virtualoccurenceofuactNCIRuid {vector} {list} {ncivalue} {errorcode} =(virtualoccurenceofuactNCIRuid({vector},{list},{ncivalue},{errorcode}))
[condition][]the {pos} position_of {field} is not equal to {value}=(virtualPositionOftagValueNotEqualToValue({pos},(xcb.xpath({field})).stringValue(),{value}))
[condition][]the field {field} is numeric with the last character as the {char}=((new DatatypeCheck()).numericWithLastCharacter((xcb.xpath({field})).stringValue(),{char}))
[condition][]the {field} is compared with the specified {segnum} at the positions {pos1} to {pos2} with the specified {value}=((new Position()).compareSpecifiedSegmentWithCharPositionInValue((xcb.xpath({field})).stringValue(),{segnum},{pos1},{pos2},{value}))
[condition][]any occurance of the {field1withxpath} is equal to comma seperated values{values}=((new Occurence()).anyOccurenceEqualToValues((xcb.xpath({field1withxpath})).stringValue(),{values}))
[condition][]it is not true that_The field Date is a valid date in the format mmddyy=(!((new DateCheck()).isValidDate2()))
[condition][]the interface name does not exist=((new SuplementOrderCheck()).checkInterfaceId())
[condition][]it is not true that_the CCNA has_license for CLLI Table=(!((new SvcType()).getCLLILicense()))
[condition][]the {fielddate1} is not equal to {fielddate2}=((new DateCheck()).isNotEqualTo((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue()))
[condition][]the {field} contains invalid values or with valid values {commaseparatedvalues} without spaces between them or repeated=((new Contains()).containsInvalidOrValidWithoutSpaceOrRepeated((xcb.xpath({field})).stringValue(),{commaseparatedvalues}))
[condition][]the {pos} and {pos} position_of the {field} is lesser than {pos} and {pos} position=((new Position()).twoPositionValueofTagIsLessThanTheValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos}))
[condition][]it is not true that   new SuplementOrderCheck  checkResponseTagExistInRequest  =(!((new SuplementOrderCheck()).checkResponseTagExistInRequest()))
[condition][]it is not true that_virtualoccurenceofVACTandUACTCEVLAN {var0} {var1} =(!(virtualoccurenceofVACTandUACTCEVLAN({var0},{var1})))
[condition][]it is not true that_the {field} does not contain {CommaSeparatedValues}=(!((new Contains()).doesNotContains((xcb.xpath({field})).stringValue(),{CommaSeparatedValues})))
[condition][]it is not true that_anyOccurenceOfSaliTagEqualsValue {var0} {var1} {var2} {var3} {var4} =(!((new Occurence()).anyOccurenceOfSaliTagEqualsValue({var0},{var1},{var2},{var3},{var4})))
[condition][]it is not true that_cktActCheckWithPrevVer {var0} {var1} {var2} {var3} {var4} {var5} {var6} =(!((new SuplementOrderCheck()).cktActCheckWithPrevVer({var0},{var1},{var2},{var3},{var4},{var5},{var6})))
[condition][]it is not true that_virtualFS_CheckKeyValuePairExists {var0} {var1} =(!((new Occurence()).FS_CheckKeyValuePairExists({var0},{var1})))
[condition][]it is not true that_any occurence of the {fieldwithxpath} is not populated in Response=(!((new Occurence()).anyOccurenceOfFieldNotPopulatedinResponse((xcb.xpath({fieldwithxpath})).stringValue())))
[condition][]virtualIntegerToString {var0} =(virtualIntegerToString({var0}))
[condition][]it is not true that_the {pos} position_of {field} is equal to {value}=(!((new Position()).positionOftagValueEqualToValue({pos},(xcb.xpath({field})).stringValue(),{value})))
[condition][]it is not true that_the position {pos} of {field} is not_equal_to_values {commaseperatedvalues}=(!((new Position()).positionOftagValueNotEqualToValues({pos},(xcb.xpath({field})).stringValue(),{commaseperatedvalues})))
[condition][]set the activity of to {var0}=((new ReqTypeAct()).setActivity({var0}))
[condition][]the {field} has_a valid value {value}=((new isValidValue()).isValidValue((xcb.xpath({field})).stringValue(),{value}))
[condition][]the interval duration is blank for the {ccna} {nc} and {icsc}=((new IntervalDurationMatcher()).isIntervalExisting({ccna},{nc},{icsc}))
[condition][]it is not true that_the {fielddate1} is todays date=(!((new DateCheck()).isToday((xcb.xpath({fielddate1})).stringValue())))
[condition][]the substring upto colon of the {field} equals {values}=((new SvcType()).compareSvcType((xcb.xpath({field})).stringValue(),{values}))
[condition][]the {pos} and {pos} position_of the {field} is greater than {pos} and {pos} position=((new Position()).twoPositionValueofTagIsGreaterThanTheValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos}))
[condition][]it is not true that_the {field} has_the specified segment with number {segnum} whose length is less than specified {length}=(!((new LengthCheck()).segmentNumberLengthLessThan((xcb.xpath({field})).stringValue(),{segnum},{length})))
[condition][]it is not true that_the {fieldwithxpath} is not prohibited=(!((new Prohibited()).isNotProhibited((xcb.xpath({fieldwithxpath})).stringValue())))
[condition][]the {field} has_none valid values {commaseperatedvalues}=((new isValidValue()).isNoneValidValues((xcb.xpath({field})).stringValue(),{commaseperatedvalues}))
[condition][]it is not true that_is dedicated recieve customer=(!((new SuplementOrderCheck()).checkDedicatedRecieveCustomer()))
[condition][]the {field} is Alpha=((new DatatypeCheck()).checkAlpha((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the field {field} is numeric with the last character as the {char}=(!((new DatatypeCheck()).numericWithLastCharacter((xcb.xpath({field})).stringValue(),{char})))
[condition][]it is not true that_the position_of Special Character is {pos} in {field}=(!((new DatatypeCheck()).checkPositionSP({pos},(xcb.xpath({field})).stringValue())))
[condition][]it is not true that_any occurrence of servpref {section}{subsect} populated=(!(virtualAnyOccurenceOfServPrefPopulated({section},{subsect})))
[condition][]it is not true that_isValidDate1 {var0} =(!((new DateCheck()).isValidDate1({var0})))
[condition][]it is not true that_the_section {field} is not populated=(!((new Populated()).isSectionNotPopulated((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_positionOfStringInSpecifiedRange {var0} {var1} {var2} {var3} =(!((new RangeOfValues()).PositionOfStringInSpecifiedRange({var0},{var1},{var2},{var3})))
[condition][]the maximum length of {field} is {value}=((new LengthCheck()).checkMaximumlength((xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_the {field} has {N} number of segments=(!((new LengthCheck()).fieldHasNumberOfSegments((xcb.xpath({field})).stringValue(),{N})))
[condition][]virtualoccOfOTCnEVMPIDwithinsameUNIMAPPING {section} {errorcode} =(virtualoccOfOTCnEVMPIDwithinsameUNIMAPPING({section},{errorcode}))
[condition][]the {field} is not populated=((new Populated()).isNotPopulated((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the message type for the valid interface equals {values}=(!((new SuplementOrderCheck()).checkMessageType({values})))
[condition][]if {pos1} and {pos2} not in foramt {chhp} for {fdt}=((new DateFormatCheck()).time_format_chkforFDT({pos1},{pos2},{chhp},{fdt}))
[condition][]noOfCharactersinTag {var0} {var1} {var2} =((new Contains()).NoOfCharactersinTag({var0},{var1},{var2}))
[condition][]it is not true that_the {field} has_the segment with specified {segnum} whose length is greater than specified {length} to support virgule or period=(!((new LengthCheck()).virguleandPeriodSegmentNumberLengthGreaterThan((xcb.xpath({field})).stringValue(),{segnum},{length})))
[condition][]the {field} has_specified {segmentNumber} field not equal to alpha=((new DatatypeCheck()).segmentNotEqualToAlpha((xcb.xpath({field})).stringValue(),{segmentNumber}))
[condition][]it is not true that_the {fieldwithxpath} occurance is atmost {numberoftimes}=(!((new Occurence()).atmostOccurenceOf((xcb.xpath({fieldwithxpath})).stringValue(),{numberoftimes})))
[condition][]it is not true that_the ccna {fieldvalue} has_the license for the table {NCNCIICSCCLLI}=(!((new ASOGTABLE()).checkCcnaLicenseForTable((xcb.xpath({fieldvalue})).stringValue(),{NCNCIICSCCLLI})))
[condition][] new SvcType  getSvcName  =((new SvcType()).getSvcName())
[condition][]it is not true that_timeFormatWithRange {var0} {var1} {var2} =(!((new TimeFormatCheck()).timeFormatWithRange({var0},{var1},{var2})))
[condition][]it is not true that_the CCNA has_license for ICSC Table=(!((new SvcType()).getICSCLicense()))
[condition][]it is not true that_alloccuranceof field{path} not equals values{commaseperatedvalues}=(!((new Occurence()).allOccurenceOfFieldNotEqualsValues({path},{commaseperatedvalues})))
[condition][]duplicate order pon {pon} ver {ver} ccna {ccna} hdricsc {icsc} exists in DB=((new SuplementOrderCheck()).duplicateOrderCheckWithHDRICSC({pon},{ver},{ccna},{icsc}))
[condition][]any occurance of {fieldwithxpath} is there=((new Occurence()).anyOccurenceOf((xcb.xpath({fieldwithxpath})).stringValue()))
[condition][]The{field}matches with{compString}having the specified characters{numChar} from last within the comparison string=((new Position()).compnoOfCharAtLastWithTagValueAsPerCompString((xcb.xpath({field})).stringValue(),{compString},{numChar}))
[condition][]the {field} contains all lowercase alpha character directly preceded by a numeric character=((new CapitalLetterCheck()).lowercaseAlphapreceededByNumeric((xcb.xpath({field})).stringValue()))
[condition][]the {field} is numeric followed by dot and is followed by numeric=((new RangeOfValues()).isNumericFollowedByDotFollowedByNumeric((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_qtyCheckForCktact {var0} {var1} {var2} =(!((new Occurence()).qtyCheckForCktact({var0},{var1},{var2})))
[condition][]it is not true that_the sup {SupFieldValue} is populated with pon {PonFieldValue} and version {VerFieldValue} and ccna {CcnaFieldValue} and icsc {IcscFieldValue} on the current order and matching with the previous order which has_a status CANCEL=(!((new SuplementOrderCheck()).supFieldCheck({SupFieldValue},{PonFieldValue},{VerFieldValue},{CcnaFieldValue},{IcscFieldValue})))
[condition][]the {field} having last {N} characters {chars} are preced by numeric=((new Equals()).lastNcharsprecededbynumeric((xcb.xpath({field})).stringValue(),{N},{chars}))
[condition][]it is not true that_existenceOfSpaceInEntireRange {field} {range1} {range2} =(!((new SpaceCheck()).existenceOfSpaceInEntireRange((xcb.xpath({field})).stringValue(),{range1},{range2})))
[condition][]it is not true that_noOfOccurence {var0} =(!((new Occurence()).noOfOccurence({var0})))
[condition][]it is not true that_the position_ {pos} of {field} is not equal to {value}=(!((new Position()).positionOftagValueNotEqualToValue({pos},(xcb.xpath({field})).stringValue(),{value})))
[condition][]it is not true that_the_section {section} {field} is populated in any occurence with {errorcode}=(!(virtualFieldIsPopulated({section},(xcb.xpath({field})).stringValue(),{errorcode})))
[condition][]anyOccurenceOf{section}{tag} equals {commaseperatedvalues}=(virtualfieldEqualsValues({section},{tag},{commaseperatedvalues}))
[condition][]it is not true that_the {field} has_format as {format}=(!((new SpecialFormat()).formatIs((xcb.xpath({field})).stringValue(),{format})))
[condition][]the table {tablename} does not exists in the data base=((new ASOGTABLE()).checkNonExistenceOfTable({tablename}))
[condition][]it is not true that_the_length_of {field} is equal to {value}=(!((new LengthCheck()).checkLength((xcb.xpath({field})).stringValue(),{value})))
[condition][]the {field} is equal or less than {value}=((new Equals()).isEqualOrLessThan((xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_the ASR Request order exists for the pon {PON} ccna {CCNA} and icsc {ICSC}=(!((new SuplementOrderCheck()).checkRequestPonExistsInDatabase({PON},{CCNA},{ICSC})))
[condition][]virtualoccurenceofSvlanMppingfortwoocc {Vector} {errorcode} =(virtualoccurenceofSvlanMppingfortwoocc({Vector},{errorcode}))
[condition][]valueOfFieldIsEqualToccurenceOfAnotherField {var0} {var1} =((new Occurence()).valueOfFieldIsEqualToccurenceOfAnotherField({var0},{var1}))
[condition][]is dedicated recieve customer=((new SuplementOrderCheck()).checkDedicatedRecieveCustomer())
[condition][] new SuplementOrderCheck  checkTagValueInRequestforResponse  =((new SuplementOrderCheck()).checkTagValueInRequestforResponse())
[condition][]it is not true that_the {field} has_last character as upper which is followed by lower case character=(!((new CapitalLetterCheck()).lastCharUpperFollLower((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {field} has {count} comma separated values=(!((new CommaSeparatedSpace()).countCommaSeperatedValues((xcb.xpath({field})).stringValue(),{count})))
[condition][]it is not true that_the {field} has_specified {segmentNumber} field not equal to alpha=(!((new DatatypeCheck()).segmentNotEqualToAlpha((xcb.xpath({field})).stringValue(),{segmentNumber})))
[condition][]the {fieldvalue} not equal to specified values {CommaSeparatedValues} of the specified {segnum}=((new Equals()).segmentValueNotEqualToValues((xcb.xpath({fieldvalue})).stringValue(),{CommaSeparatedValues},{segnum}))
[condition][]the {field} has_only one {char} special character present=((new DatatypeCheck()).checkRepeationOFSpecialCharacter((xcb.xpath({field})).stringValue(),{char}))
[condition][]it is not true that_virtualoccurenceofVACTandUACT2CEVLAN {var0} {var1} =(!(virtualoccurenceofVACTandUACT2CEVLAN({var0},{var1})))
[condition][]check previous versison servicetype for the pon {PonFieldValue} and version {VerFieldValue} and ccna {CcnaFieldValue} and icsc {IcscFieldValue} with current rootnode value {RootnodeValue}=((new SuplementOrderCheck()).checkServiceTypeInPreviousVersion({PonFieldValue},{VerFieldValue},{CcnaFieldValue},{IcscFieldValue},{RootnodeValue}))
[condition][]the {field} contains {num} of consecutive uppercase Alpha Characters=((new CapitalLetterCheck()).containsConsecutiveUppercaseAlphaCharacters((xcb.xpath({field})).stringValue(),{num}))
[condition][]it is not true that_the {field} has_consecutive uppercase characters and should not be followed by space=(!((new CapitalLetterCheck()).consecUpperCaseWithNoSpaceAfter((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the interval duration is blank for the {ccna} {nc} and {icsc}=(!((new IntervalDurationMatcher()).isIntervalExisting({ccna},{nc},{icsc})))
[condition][]the {field} contains all lowercase alpha characters directly preceded by a numeric character=((new CapitalLetterCheck()).lowercaseAlphaCharactersPreceededByNumeric((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_any occurence of{fieldwithxpath} is not populated=(!((new Occurence()).anyOccurenceOfFieldNotPopulated((xcb.xpath({fieldwithxpath})).stringValue())))
[condition][]the CCNA has_license for NC Table=((new SvcType()).getNCLicense())
[condition][]the ccna{ccna} and icsc{icsc} combination exists=((new SuplementOrderCheck()).checkCcnaIcscCombination({ccna},{icsc}))
[condition][]it is not true that_the{field} has_the last character not_equal_to_values{value}=(!((new Equals()).lastCharacterOfFieldNotEqualValues((xcb.xpath({field})).stringValue(),{value})))
[condition][]the {field} not equals {value}=((new Equals()).isNotEquals((xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_the ICSC has_license for NCNCICOMPATIBILITY Table=(!((new SvcType()).getIcscCLLILicense()))
[condition][]checkTagValue pon {field} ver {field} ccna {field} icsc {field} section {section} tag {tag} equalsvalue {value} pos {pos}InRequestforResponse=((new SuplementOrderCheck()).checkTagValueInRequestforResponse((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),{section},{tag},{value},{pos}))
[condition][]it is not true that_confirmationOrderCheck pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}=(!((new SuplementOrderCheck()).confirmationOrderCheck({pon},{ver},{ccna},{icsc},{description})))
[condition][]CHECK FIRMORDER request{field} pon{field} ver{field} ccna{field} icsc{field}=((new SuplementOrderCheck()).firmOrderToServiceRequestCheck((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue()))
[condition][]it is not true that   new ReqTypeAct  getActivity  =(!((new ReqTypeAct()).getActivity()))
[condition][]it is not true that_the occurance of {fieldwithxpath} is greaterthan {number}=(!((new Occurence()).noOfOccurenceGreaterThan((xcb.xpath({fieldwithxpath})).stringValue(),{number})))
[condition][]the sup {SupFieldValue} is populated with act {ActFieldValue} and pon {PonFieldValue} and version {VerFieldValue} and ccna {CcnaFieldValue} and icsc {IcscFieldValue} on the current order and does not have same ACT on the previous order=((new SuplementOrderCheck()).actFieldCheck({SupFieldValue},{ActFieldValue},{PonFieldValue},{VerFieldValue},{CcnaFieldValue},{IcscFieldValue}))
[condition][]setCLLILicense {var0} =((new SvcType()).setCLLILicense({var0}))
[condition][]it is not true that_routing matrix value check when any ALL is present{section}{subsect}{field}=(!(virtualRoutingMatrixCheck1({section},{subsect},(xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the CCNA has_license for NC Table=(!((new SvcType()).getNCLicense()))
[condition][]the {field} is AlphaNumeric with only space as special character=((new DatatypeCheck()).checkAlphaNumericWithSpaceAsSpecialCharacter((xcb.xpath({field})).stringValue()))
[condition][]for the Trading Partner with the ICSC {icscvalue} the {datevalue} falls on holiday=((new HOLIDAY()).fetchTPHoliday({icscvalue},{datevalue}))
[condition][]it is not true that_the {field} at the position {start} to {end} does not contain any Alpha Numeric characters =(!((new RangeOfValues()).noExistenceOfAlpha_NumericAtSpecRange((xcb.xpath({field})).stringValue(),{start},{end})))
[condition][]the {field} does not match with {field2} at the specified character positions {pos1} to {pos2}=((new Position()).compStringDoesntMatchTagValueAtSpecPosition((xcb.xpath({field})).stringValue(),(xcb.xpath({field2})).stringValue(),{pos1},{pos2}))
[condition][]it is not true that_asogCutOverOrderReject {ver} {icsc} {msgtimestamp} =(!((new AsogGuidelineVersion()).asogCutOverOrderReject({ver},{icsc},{msgtimestamp})))
[condition][]the {field} has_specified {segmentNumber} not equal to numeric=((new DatatypeCheck()).segmentNotEqualToNumeric((xcb.xpath({field})).stringValue(),{segmentNumber}))
[condition][]virguleandPeriodSegmentValueEqualToValues {var0} {var1} {var2} =((new Equals()).virguleandPeriodSegmentValueEqualToValues({var0},{var1},{var2}))
[condition][]characterPreceededOrFollowedByNumeric {var0} {var1} =((new Contains()).characterPreceededOrFollowedByNumeric({var0},{var1}))
[condition][]it is not true that_the {fieldvalue} is present in NC table =(!((new ASOGTABLE()).fetchAbbreviationNCTable((xcb.xpath({fieldvalue})).stringValue())))
[condition][]checkResponse_IcscTagExistInRequestIcsc {var0} {var1} {var2} {var3} =((new SuplementOrderCheck()).checkResponse_IcscTagExistInRequestIcsc({var0},{var1},{var2},{var3}))
[condition][]the {fielddate1} is less than or equal to {fielddate2}=((new DateCheck()).isLessThanOrEqualTo((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue()))
[condition][]it is not true that_getSaliParent of{parent} in{section} for{tag}=(!((new Occurence()).getSaliParent({parent},{section},{tag})))
[condition][]virtualCanopiWebService {var0} =(virtualCanopiWebService({var0}))
[condition][]the{section}{subsect}{field} populated and assosiated tag{tag}is not populated or corresponding section tag{corrstag}not equals to {values}=(virtualLrefListFieldPopulatedAssoTagIsNotPopulatedOrCorrespondingTagNotEqualsVlaues({section},{subsect},(xcb.xpath({field})).stringValue(),{tag},{corrstag},{values}))
[condition][]it is not true that_the {field} contains {num} of consecutive lowercase Alpha Characters=(!((new CapitalLetterCheck()).containsConsecutiveLowercaseAlphaCharacters((xcb.xpath({field})).stringValue(),{num})))
[condition][]it is not true that_the {field} is numeric with trailing spaces=(!((new DatatypeCheck()).checkNumericWithTrailingSPacesOnly((xcb.xpath({field})).stringValue())))
[condition][]the {field} is Numeric with Special Characters=((new DatatypeCheck()).checkNumericSP((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_getLatestVersion {var0} {var1} =(!((new SuplementOrderCheck()).getLatestVersion({var0},{var1})))
[condition][]it is not true that_virtualoccurenceofVACTandUACT {section} {errorcode} =(!(virtualoccurenceofVACTandUACT({section},{errorcode})))
[condition][]it is not true that_the {field} is compared with the specified {segnum} at the positions {pos1} to {pos2} with the specified {value}=(!((new Position()).compareSpecifiedSegmentWithCharPositionInValue((xcb.xpath({field})).stringValue(),{segnum},{pos1},{pos2},{value})))
[condition][]it is not true that_the {fieldvalue} is present in the LOCATION table=(!((new ASOGTABLE()).fetchAbbreviationLOCATIONTable((xcb.xpath({fieldvalue})).stringValue())))
[condition][]the {fieldvalue} is in HHMMA HHMMP format and the difference is equal to or greater than {value} hours=((new TimeFormatCheck()).appointmentTimeFormatRange((xcb.xpath({fieldvalue})).stringValue(),{value}))
[condition][]any occurence of the {fieldwithxpath} is not populated in Response=((new Occurence()).anyOccurenceOfFieldNotPopulatedinResponse((xcb.xpath({fieldwithxpath})).stringValue()))
[condition][]it is not true that_the version {VER} is not one greater than the previous database version for the pon {PON} ccna {CCNA} and icsc {ICSC} with status {status}=(!((new SuplementOrderCheck()).verNotOneGreaterThanLatestDBVersion({VER},{PON},{CCNA},{ICSC},{status})))
[condition][]the position_of Numeric is {pos} in {field}=((new DatatypeCheck()).checkPositionNumeric({pos},(xcb.xpath({field})).stringValue()))
[condition][]virtualoccOfF1nF2andVAL1nVAL2withinsameUNIMAPPING {section} {errorcode} {field1} {F1values} {field2} {F2values} {field3} =(virtualoccOfF1nF2andVAL1nVAL2withinsameUNIMAPPING({section},{errorcode},(xcb.xpath({field1})).stringValue(),{F1values},(xcb.xpath({field2})).stringValue(),{F2values},(xcb.xpath({field3})).stringValue()))
[condition][]it is not true that_checkCapsInField2ForPosInField1 {var0} {var1} {var2} =(!((new CapitalLetterCheck()).checkCapsInField2ForPosInField1({var0},{var1},{var2})))
[condition][]it is not true that_the interval between {fielddate1} and {fielddate2} is greater than or equal to {days}=(!((new DateCheck()).intervalBetweenTwoDateIsGreaterThanOrEqualToDays((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue(),{days})))
[condition][]tagValueEqualsInPreviousVersion {var0} {var1} {var2} {var3} {var4} {var5} {var6} =((new SuplementOrderCheck()).tagValueEqualsInPreviousVersion({var0},{var1},{var2},{var3},{var4},{var5},{var6}))
[condition][]spaceFollowedBySpaceFollowedByChar {var0} =((new SpaceCheck()).spaceFollowedBySpaceFollowedByChar({var0}))
[condition][]it is not true that_the {fielddate1} is equal to {fielddate2}=(!((new DateCheck()).isEqualTo((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue())))
[condition][]it is not true that_Is the {fieldDate1} less than {comparisonDate} in the format {CCYYMMDD}=(!((new DateFormatCheck()).isFieldDateLessThanComparisonDateInspecifiedFormat((xcb.xpath({fieldDate1})).stringValue(),{comparisonDate},{CCYYMMDD})))
[condition][]it is not true that_virtualoccurenceofuactNCI {vector} {list} {ncivalue} {errorcode} =(!(virtualoccurenceofuactNCI({vector},{list},{ncivalue},{errorcode})))
[condition][]the {field} is populated=((new Populated()).isPopulated((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the value of {field1withxpath} is equal to number of occurance of {field2withxpath}=(!((new Occurence()).tagValueOfOneFieldEqualToNoOfOccurenceOfAnotherField((xcb.xpath({field1withxpath})).stringValue(),(xcb.xpath({field2withxpath})).stringValue())))
[condition][]the CCNA has_license for CLLI Table=((new SvcType()).getCLLILicense())
[condition][]it is not true that_the {fielddate1} is a Holiday=(!((new DateCheck()).isInHolidayList((xcb.xpath({fielddate1})).stringValue())))
[condition][]it is not true that_the {field} is Numeric without Special Characters Set {setofspecialcharacters}=(!((new DatatypeCheck()).checkNumericWithOutSPSet((xcb.xpath({field})).stringValue(),{setofspecialcharacters})))
[condition][]it is not true that_any occurence of multiple {field} is populated=(!((new Occurence()).anyOccurenceOfMultipleFieldIsPopulated((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {section}{field} is not populated in all occurence=(!((new Occurence()).VirtualNoOccurenceIsPopulated({section},(xcb.xpath({field})).stringValue())))
[condition][]the {field} is Numeric=((new DatatypeCheck()).checkNumeric((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the difference for the given {CCNA} {NC} and {ICSC} between the {ASRDDD} and the current date is less than the Interval Duration from the table=(!((new IntervalDurationMatcher()).isIntervalDurationMatching({CCNA},{NC},{ICSC},{ASRDDD})))
[condition][]it is not true that_the order with asog version {ver} icsc {icsc} and {msgtimestamp} cannot be submitted because of ASOG Upgrade=(!(virtualAsogCutOverOrderReject({ver},{icsc},{msgtimestamp})))
[condition][]it is not true that_segmentEqualToAlphaNumericWithSPChar {var0} {var1} {var2} =(!((new DatatypeCheck()).segmentEqualToAlphaNumericWithSPChar({var0},{var1},{var2})))
[condition][]the {fieldvalue} is present in NCI table =((new ASOGTABLE()).fetchAbbreviationNCITable((xcb.xpath({fieldvalue})).stringValue()))
[condition][]it is not true that_the {field} has_specified {segmentNumber} field not equal to alpha with virgule or period as delimiter=(!((new DatatypeCheck()).virguleandPeriodSegmentNotEqualToAlpha((xcb.xpath({field})).stringValue(),{segmentNumber})))
[condition][]the{section}{subsect}{field}not populated and assosiated tag{tag}is populated and corresponding section tag{corrstag}equals to {values}=(virtualLrefListFieldIsNotPopulatedAssoTagIsPopulatedandCorrespondingTagEqualsVlaue({section},{subsect},(xcb.xpath({field})).stringValue(),{tag},{corrstag},{values}))
[condition][]virtualoccurenceofuactRuid {vector} {list} {errorcode} =((new Occurence()).virtauloccurenceofuactRuid({vector},{list},{errorcode}))
[condition][]the {field} has {count} comma separated values=((new CommaSeparatedSpace()).countCommaSeperatedValues((xcb.xpath({field})).stringValue(),{count}))
[condition][]it is not true that_isCurrentDateLessThanOrNotEqualToDesiredDueDate {var0} =(!((new DateCheck()).isCurrentDateLessThanOrNotEqualToDesiredDueDate({var0})))
[condition][]it is not true that_the {field} from positions {pos1} to {pos2} is not populated and not spaces=(!((new Populated()).rangeOfPositionIsNotPopulatedAndNotSpaces((xcb.xpath({field})).stringValue(),{pos1},{pos2})))
[condition][]the {pos} position_Of {field} equal to {value}=((new Contains()).positionOfFieldEqualToValue({pos},(xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_the {field} has_segment with specified {segnum} of the specified {length}=(!((new LengthCheck()).segmentNumberLengthEqualTo((xcb.xpath({field})).stringValue(),{segnum},{length})))
[condition][]the {field} contains atleast one non space character in the range {start} to {end}=((new SpaceCheck()).checkAtleastOneNonSpaceInRange((xcb.xpath({field})).stringValue(),{start},{end}))
[condition][]it is not true that_the {field} has {commaseperatedvalues}=(!((new ValidValueCheck()).validCommaSeperatedValue((xcb.xpath({field})).stringValue(),{commaseperatedvalues})))
[condition][]the {field} at the position {start} to {end} does not contain any Alpha Numeric characters =((new RangeOfValues()).noExistenceOfAlpha_NumericAtSpecRange((xcb.xpath({field})).stringValue(),{start},{end}))
[condition][]any occurance of the {field1withxpath} is not equal to {value}=((new Occurence()).anyOccurenceNotEqualToValue((xcb.xpath({field1withxpath})).stringValue(),{value}))
[condition][]it is not true that_the {field} contains all lowercase alpha character directly preceded by a numeric character=(!((new CapitalLetterCheck()).lowercaseAlphapreceededByNumeric((xcb.xpath({field})).stringValue())))
[condition][]the{section}{field}is populated and assosiated tag{tag} not equals to values{values}=(virtualAnyOccurenceOfFieldPopulatedAndAssosiatedTagNotEqualsValues({section},(xcb.xpath({field})).stringValue(),{tag},{values}))
[condition][]the {field} contains numeric characters=((new Contains()).containsNumeric((xcb.xpath({field})).stringValue()))
[condition][]the {fieldName} in {parentSection} is less than {fieldValue} for the {pon} {ver} {ccna} {icsc}=((new SuplementOrderCheck()).isCurrentDDDLessThanPreviousVersionDDD((xcb.xpath({fieldName})).stringValue(),{parentSection},(xcb.xpath({fieldValue})).stringValue(),{pon},{ver},{ccna},{icsc}))
[condition][]it is not true that_the interface name does not exist=(!((new SuplementOrderCheck()).checkInterfaceId()))
[condition][]it is not true that_the {pos} to {pos} of the {field1} is equal to {pos} to {pos} of the {field2}=(!((new Position()).twoPositionRangeValueofTagEqualToValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field1})).stringValue(),{pos},{pos},(xcb.xpath({field2})).stringValue())))
[condition][]it is not true that_virtualoccOfVPNIDnSVLANSTARTnASNwithinsameUNIMAPPING {section} {errorcode} =(!(virtualoccOfVPNIDnSVLANSTARTnASNwithinsameUNIMAPPING({section},{errorcode})))
[condition][]virtualoccOfVPNIDnSVLANSTARTwithinsameUNIMAPPING {section} {errorcode} =(virtualoccOfVPNIDnSVLANSTARTwithinsameUNIMAPPING({section},{errorcode}))
[condition][]alloccuranceof field{path} not equals values{commaseperatedvalues}=((new Occurence()).allOccurenceOfFieldNotEqualsValues({path},{commaseperatedvalues}))
[condition][]it is not true that_the {pos} position_of {field} field_is_equal_to_values {commaseperatedvalues}=(!((new Position()).positionOftagValueEqualToValues({pos},(xcb.xpath({field})).stringValue(),{commaseperatedvalues})))
[condition][]it is not true that_the {field} has_virgule or period as delimiter=(!((new DatatypeCheck()).fieldHasOneDelimiter((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_Spec_Lrefchk{Lref} Lref{lref} spec{spec} and occurance{occurance} with errorCode {errorcode}=(!(virtualSpecLrefchk({Lref},{lref},{spec},{occurance},{errorcode})))
[condition][]{field} has_atleast {occurance} occurances populated=((new Occurence()).atleastOccurenceOfTagPopulated((xcb.xpath({field})).stringValue(),{occurance}))
[condition][]the {pos} position_of {field} is not_equal_to_values {commaseperatedvalues}=(virtualPositionOftagValueNotEqualToValues({pos},(xcb.xpath({field})).stringValue(),{commaseperatedvalues}))
[condition][]it is not true that_all occurences of{fieldwithxpath} not equals to{value}=(!((new Occurence()).allOccurenceOfFieldNotEqualToValue((xcb.xpath({fieldwithxpath})).stringValue(),{value})))
[condition][]it is not true that_the {field} is NotProhibited=(!((new Prohibited()).isNotProhibited((xcb.xpath({field})).stringValue())))
[condition][]the {fieldvalue} is populated in segment {segnum} after {value}=(virtualPositionAfterDelimeterPopulated((xcb.xpath({fieldvalue})).stringValue(),{segnum},{value}))
[condition][]the multiple field{field} has_length greater than{value} in any occurence=((new Occurence()).lengthCheckForMultipleOccuringTag((xcb.xpath({field})).stringValue(),{value}))
[condition][]all occurence of{section}{field} not equals{value} erroring to last occurence with{errorcode}=(virtualAllOccurenceOfFieldNotEqualsValue({section},(xcb.xpath({field})).stringValue(),{value},{errorcode}))
[condition][]the field {field} has_pattern {pattern}=((new SpecialFormat()).patternChecking((xcb.xpath({field})).stringValue(),{pattern}))
[condition][]the pon {PON} ccna {CCNA}  icsc{ICSC} and ver{ver} combination has_the response with description {DESCRIPTION} and the previous version SUP1 order with status {CURRENTSTATUS} for the xml {xmlins}=(virtual_prevOrderSUP1CheckWithRespAccept({PON},{CCNA},{ICSC},{ver},{DESCRIPTION},{CURRENTSTATUS},{xmlins}))
[condition][]it is not true that_the {pos1} to {pos2} of the {field} is present in LOCATION Table=(!((new ASOGTABLE()).posToPosfetchAbbreviationLOCATIONTable({pos1},{pos2},(xcb.xpath({field})).stringValue())))
[condition][]it is not true that_checkAlphaNumericWithASingleSpecialCharacter {var0} {var1} =(!((new DatatypeCheck()).checkAlphaNumericWithASingleSpecialCharacter({var0},{var1})))
[condition][]it is not true that_The{field}matches with{compString}having the specified characters{numChar} from last within the comparison string=(!((new Position()).compnoOfCharAtLastWithTagValueAsPerCompString((xcb.xpath({field})).stringValue(),{compString},{numChar})))
[condition][]it is not true that_Is the {fieldDate1} not equal to {comparisonDate} in the format {CCYYMMDD}=(!((new DateFormatCheck()).isFieldNotEqualToComparisonDateInspecifiedFormat((xcb.xpath({fieldDate1})).stringValue(),{comparisonDate},{CCYYMMDD})))
[condition][]any occurence of {section}{field} is not populated with {errorcode}=((new Occurence()).VirtualAnyOccurenceIsNotPopulated({section},(xcb.xpath({field})).stringValue(),{errorcode}))
[condition][]it is not true that_lrefListFieldPopulatedAssoTagIsNotPopulatedOrCorrespondingTagNotEqualsVlaues {var0} {var1} {var2} {var3} {var4} {var5} {var6} =(!((new Occurence()).lrefListFieldPopulatedAssoTagIsNotPopulatedOrCorrespondingTagNotEqualsVlaues({var0},{var1},{var2},{var3},{var4},{var5},{var6})))
[condition][]the_section {section} {field} is populated in any occurence with {errorcode}=(virtualFieldIsPopulated({section},(xcb.xpath({field})).stringValue(),{errorcode}))
[condition][]it is not true that_the substring upto colon of the {field} equals {values}=(!((new SvcType()).compareSvcType((xcb.xpath({field})).stringValue(),{values})))
[condition][]the_section {field} is not populated=((new Populated()).isSectionNotPopulated((xcb.xpath({field})).stringValue()))
[condition][]the {field} has_space as a special character=((new SpaceCheck()).spaceAsSpecialCharacter((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {pos} and {pos} position_of the {field} is greater than or equal to {pos} and {pos} position=(!((new Position()).twoPositionValueofTagIsGreaterThanOrEqualToTheValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos})))
[condition][]positionOfAnyFieldNotEqualToCharacter {var0} {var1} {var2} =((new Occurence()).positionOfAnyFieldNotEqualToCharacter({var0},{var1},{var2}))
[condition][]it is not true that_virtualIntegerToString {var0} =(!(virtualIntegerToString({var0})))
[condition][]the {field} has_both uppercase and lowercase characters=((new CapitalLetterCheck()).isUpperAndLowerCase((xcb.xpath({field})).stringValue()))
[condition][]the {fielddate1} is a Holiday=((new DateCheck()).isInHolidayList((xcb.xpath({fielddate1})).stringValue()))
[condition][]the field {field} with segment {segnum} is populated=((new Populated()).segmentIsPopulated((xcb.xpath({field})).stringValue(),{segnum}))
[condition][]the {fielddate1} is less than {fielddate2}=((new DateCheck()).isLessThan((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue()))
[condition][]the CCNA has_license for ICSC Table=((new SvcType()).getICSCLicense())
[condition][]it is not true that_the interval duration is blank for the {nc}=(!((new IntervalDurationMatcher()).isIntervalExisting({nc})))
[condition][]it is not true that_the {field} not equal to specified {value} of the specified {segnum}=(!((new Equals()).segmentValueNotEqualToEnteredValue((xcb.xpath({field})).stringValue(),{value},{segnum})))
[condition][]AnyOccoffield1withsection{multiecoec} field1 {OECICSC}equals field2{field2} with values {value1} and {value2} with errorCode {errorcode}=(virtualAnyOccoffield1equalsvaluewherefield2notequalsvalue({multiecoec},{OECICSC},(xcb.xpath({field2})).stringValue(),{value1},{value2},{errorcode}))
[condition][]it is not true that_routing matrix value check when first column is ALL{section}{subsect}{field}=(!(virtualRoutingMatrixCheck2({section},{subsect},(xcb.xpath({field})).stringValue())))
[condition][]noOfOccurancesOfTagValueIsUniqueForAnotherTagValueSet {var0} {var1} {var2} =((new Occurence()).noOfOccurancesOfTagValueIsUniqueForAnotherTagValueSet({var0},{var1},{var2}))
[condition][]all occurences of {section} of field {field} equals the value{value} with errorcode {errorcode}=(virtualAllOccurenceOfFieldEqualsValue({section},(xcb.xpath({field})).stringValue(),{value},{errorcode}))
[condition][]it is not true that_checkCcnaIcscCombinationInSECONDARYSOURCETARGETINFO {xmlInstance} {ccna} {icsc} =(!((new SuplementOrderCheck()).checkCcnaIcscCombinationInSECONDARYSOURCETARGETINFO({xmlInstance},{ccna},{icsc})))
[condition][]the {field} has_words seperated by a comma=((new DatatypeCheck()).commaPresenceForMoreThanOneWord((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_isRequired {var0} =(!((new Required()).isRequired({var0})))
[condition][]the position_ {pos} of {field} is not equal to {value}=((new Position()).positionOftagValueNotEqualToValue({pos},(xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_the {fielddate1} is a valid date=(!((new DateCheck()).isValidDate((xcb.xpath({fielddate1})).stringValue())))
[condition][]it is not true that_allLowerCase {var0} =(!((new CapitalLetterCheck()).allLowerCase({var0})))
[condition][]the {field} has_the specified {value} in the range {start} to {end}=((new RangeOfValues()).compareSpecStringInRange((xcb.xpath({field})).stringValue(),{value},{start},{end}))
[condition][]it is not true that_the CCNA has_license for NCI Table=(!((new SvcType()).getNCILicense()))
[condition][]it is not true that_the {pos} position_of {field1} is equal to {pos} position_of {field2}=(!((new Position()).positionOfOneFieldIsEqualToPositionOfAnother({pos},(xcb.xpath({field1})).stringValue(),{pos},(xcb.xpath({field2})).stringValue())))
[condition][]any occurence of multiple {field} is populated=((new Occurence()).anyOccurenceOfMultipleFieldIsPopulated((xcb.xpath({field})).stringValue()))
[condition][]confirmationOrderCheck {var0} {var1} {var2} {var3} =((new SuplementOrderCheck()).confirmationOrderCheck({var0},{var1},{var2},{var3}))
[condition][]it is not true that_the {field} from {pos1} to {pos2} of the segment{segnum} are not alpha characters to supportvirgule or period as delimiter=(!((new LengthCheck()).virguleandPeriodPosToPosOfSegmentAreNotAlpha((xcb.xpath({field})).stringValue(),{pos1},{pos2},{segnum})))
[condition][]it is not true that_characterPreceededOrFollowedByNumeric {var0} {var1} =(!((new Contains()).characterPreceededOrFollowedByNumeric({var0},{var1})))
[condition][]the {pos} and {pos} position_of the {field} is not equal to {pos} and {pos} position=((new Position()).twoPositionValueofTagNotEqualToValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos}))
[condition][]virtualoccurenceofVACTandUACT3CEVLAN {var0} {var1} =(virtualoccurenceofVACTandUACT3CEVLAN({var0},{var1}))
[condition][]getLatestValidVersionInDataBaseWithStatus {var0} {var1} {var2} =((new SuplementOrderCheck()).getLatestValidVersionInDataBaseWithStatus({var0},{var1},{var2}))
[condition][]checkCapsInField2ForPosInField1 {var0} {var1} {var2} =((new CapitalLetterCheck()).checkCapsInField2ForPosInField1({var0},{var1},{var2}))
[condition][]it is not true that_the difference between {fielddate1} and {fielddate2} is equal to one year=(!((new DateCheck()).isRangeEqualToOneYear((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue())))
[condition][]setIcscCLLILicense {var0} =((new SvcType()).setIcscCLLILicense({var0}))
[condition][]it is not true that_the {pos} and {pos} position_of the {field} is lesser than {pos} and {pos} position=(!((new Position()).twoPositionValueofTagIsLessThanTheValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos})))
[condition][]the {field} is NotProhibited=((new Prohibited()).isNotProhibited((xcb.xpath({field})).stringValue()))
[condition][]Is the {fieldDate1} less than {comparisonDate} in the format {CCYYMMDD}=((new DateFormatCheck()).isFieldDateLessThanComparisonDateInspecifiedFormat((xcb.xpath({fieldDate1})).stringValue(),{comparisonDate},{CCYYMMDD}))
[condition][]the {field} does not match with {compstring} having the specified Characters {numChar} from last within the comparison string=((new Position()).CompStringDoesntMatchWithSpecifiedChars((xcb.xpath({field})).stringValue(),{compstring},{numChar}))
[condition][]the {field} has_virgule or period as delimiter=((new DatatypeCheck()).fieldHasOneDelimiter((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} is Prohibited for {commaseperatedvalues}=(!((new Prohibited()).prohibitedForValues((xcb.xpath({field})).stringValue(),{commaseperatedvalues})))
[condition][]the pon {field} ver {field} section {section} tag {tag} is populated in Request against Response=((new SuplementOrderCheck()).checkResponseTagExistInRequest((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),{section},{tag}))
[condition][]it is not true that_the {field} has_all uppercase characters=(!((new CapitalLetterCheck()).isAllUpperCase((xcb.xpath({field})).stringValue())))
[condition][]the {field} has_not a valid values {commaseperatedvalues}=((new isValidValue()).isNotValidValues((xcb.xpath({field})).stringValue(),{commaseperatedvalues}))
[condition][]the_section {section} for the field {feild} with {compvalue} and {innercompvalue} for field {innerfeild} and {errorcode}=(virtualoccurenceofSvlanMapping({section},{feild},{compvalue},{innercompvalue},{innerfeild},{errorcode}))
[condition][]it is not true that_the occurance of {fieldwithxpath} is equal to {number}=(!((new Occurence()).noOfOccurenceEqualTo((xcb.xpath({fieldwithxpath})).stringValue(),{number})))
[condition][]the {field} is according to the specified {format}=((new SpecialFormat()).isFieldAccordingToFormat((xcb.xpath({field})).stringValue(),{format}))
[condition][]it is not true that_the value of{field} is not equal to occurence of the {fieldwithxpath}=(!((new Occurence()).valueOfFieldIsNotEqualToccurenceOfAnotherField((xcb.xpath({field})).stringValue(),(xcb.xpath({fieldwithxpath})).stringValue())))
[condition][]it is not true that_section{section} tag{tag} not populated=(!(virtualNotPopulated({section},{tag})))
[condition][]the sup {SupFieldValue} is populated with pon {PonFieldValue} and version {VerFieldValue} and ccna {CcnaFieldValue} and icsc {IcscFieldValue} on the current order and matching with the previous order which has_a status COMPLETED=((new SuplementOrderCheck()).completionOrderCheck({SupFieldValue},{PonFieldValue},{VerFieldValue},{CcnaFieldValue},{IcscFieldValue}))
[condition][]the field {fieldname} with parent section {parentname} is populated in previous version for the pon {PON} ver {VER} ccna {CCNA} and icsc {ICSC}=((new SuplementOrderCheck()).fieldPopulatedInPreviousVersion((xcb.xpath({fieldname})).stringValue(),{parentname},{PON},{VER},{CCNA},{ICSC}))
[condition][]it is not true that_virtualoccurenceofVACTandUACT3 {section} {errorcode} =(!(virtualoccurenceofVACTandUACT3({section},{errorcode})))
[condition][]it is not true that_the {field} with segment{segnum} is populated=(!((new DatatypeCheck()).segmentPopulated((xcb.xpath({field})).stringValue(),{segnum})))
[condition][]it is not true that_the {field} has_both uppercase and lowercase characters for comma seperated vaules=(!((new CapitalLetterCheck()).isUpperAndLowerCaseForCSV((xcb.xpath({field})).stringValue())))
[condition][]the {field} contains {num} of spaces before Alpha Characters=((new CapitalLetterCheck()).containsConsecutiveSpacesBeforeAlphaCharacters((xcb.xpath({field})).stringValue(),{num}))
[condition][]getSaliParent of{parent} in{section} for{tag}=((new Occurence()).getSaliParent({parent},{section},{tag}))
[condition][]the {pos} and {pos} position_of the {field} is lesser than or equal to {pos} and {pos} position=((new Position()).twoPositionValueofTagIsLessThanOrEqualToTheValueOfAnotherTwoPosition({pos},{pos},(xcb.xpath({field})).stringValue(),{pos},{pos}))
[condition][]virtualALCONfieldPopulated {priloc} {secloc} {errorcode} =(virtualALCONfieldPopulated({priloc},{secloc},{errorcode}))
[condition][]it is not true that_duplicate order pon {pon} ver {ver} ccna {ccna} hdricsc {icsc} exists in DB=(!((new SuplementOrderCheck()).duplicateOrderCheckWithHDRICSC({pon},{ver},{ccna},{icsc})))
[condition][]existenceOfSpaceInEntireRange {field} {range1} {range2} =((new SpaceCheck()).existenceOfSpaceInEntireRange((xcb.xpath({field})).stringValue(),{range1},{range2}))
[condition][]The {field} contains whitespaces or numbers in range or zeros from second position_to end=((new Position()).charAtPositionCheck((xcb.xpath({field})).stringValue()))
[condition][]setICSCNCNCICompatibilityLicense {var0} =((new SvcType()).setICSCNCNCICompatibilityLicense({var0}))
[condition][]it is not true that_atleast any one of the segment delimeted by the char {delimchar} of the {field} does not contain Alpha character followed by maximum number {num} of numeric characters=(!(virtualSegmentsDoesNotContainsAlphafollowedByNumerics({delimchar},(xcb.xpath({field})).stringValue(),{num})))
[condition][]it is not true that_virtualOccurenceofEIandUACTinUNIMAPPING {section} {errorcode} =(!(virtualOccurenceofEIandUACTinUNIMAPPING({section},{errorcode})))
[condition][]the {field} with segment {segnum} is not populated=((new Populated()).segmentIsNotPopulated((xcb.xpath({field})).stringValue(),{segnum}))
[condition][]the{field} has_the last character not_equal_to_values{value}=((new Equals()).lastCharacterOfFieldNotEqualValues((xcb.xpath({field})).stringValue(),{value}))
[condition][]the_section{section} parent{parent} tag {tag} has_value{value} in any occurence=(virtualAnyOccurenceOfSaliTagEqualsValue({section},{parent},{tag},{value}))
[condition][]it is not true that_fieldPositionInRange {var0} {var1} {var2} {var3} =(!((new RangeOfValues()).fieldPositionInRange({var0},{var1},{var2},{var3})))
[condition][]it is not true that_the {field} has_specified range {start} to {end}=(!((new RangeOfValues()).rangeCheckNN_NN((xcb.xpath({field})).stringValue(),{start},{end})))
[condition][]the {field} has_specified segment {segnum} which has_the specified alpha {specAlpha}=((new DatatypeCheck()).segmentNotEqualToSpecifiedAlpha((xcb.xpath({field})).stringValue(),{segnum},{specAlpha}))
[condition][]it is not true that_occurenceOfFieldIsGreaterThanSpecifiedNumberWithGivenValue {var0} {var1} {var2} =(!((new Occurence()).occurenceOfFieldIsGreaterThanSpecifiedNumberWithGivenValue({var0},{var1},{var2})))
[condition][] new ReqTypeAct  getRequestType  =((new ReqTypeAct()).getRequestType())
[condition][]it is not true that_setNCNCICompatibilityLicense  {var0} =(!((new SvcType()).setNCNCICompatibilityLicense({var0})))
[condition][]the sup {SupFieldValue} is populated with pon {PonFieldValue} and version {VerFieldValue} and ccna {CcnaFieldValue} and icsc {IcscFieldValue} and qty {QtyFieldValue} on the current order which has_decreasing QTY with respect to the previous order=((new SuplementOrderCheck()).qtyFieldCheck({SupFieldValue},{PonFieldValue},{VerFieldValue},{CcnaFieldValue},{IcscFieldValue},{QtyFieldValue}))
[condition][]it is not true that_the {field} not equals {value}=(!((new Equals()).isNotEquals((xcb.xpath({field})).stringValue(),{value})))
[condition][]it is not true that_the pon {PON} ccna {CCNA} and icsc{ICSC} combination has_the response with description {DESCRIPTION} and the previous version SUP1 has_order with status {CURRENTSTATUS} for the xml {xmlins}=(!(virtual_prevOrderSUP1CheckWithRespReject({PON},{CCNA},{ICSC},{DESCRIPTION},{CURRENTSTATUS},{xmlins})))
[condition][]it is not true that_numericCheckFormat {var0} {var1} {var2} =(!((new SpecialFormat()).NumericCheckFormat({var0},{var1},{var2})))
[condition][]the position_of Special Character is {pos} in {field}=((new DatatypeCheck()).checkPositionSP({pos},(xcb.xpath({field})).stringValue()))
[condition][]it is not true that_getvalue {var0} =(!((new Occurence()).getvalue({var0})))
[condition][]it is not true that_setIcscCLLILicense {var0} =(!((new SvcType()).setIcscCLLILicense({var0})))
[condition][]the pos {pos} to {pos} of segment {segnum} of the field {field} does not_equal_to_values {commaseparatedvalues}=((new LengthCheck()).posToPosOfSegmentNotEquals({pos},{pos},{segnum},(xcb.xpath({field})).stringValue(),{commaseparatedvalues}))
[condition][]the value of {field} not equals the occurences of{section}=(virtualsaliValueOfFieldNotEqualsOccurenceOfOtherSection1((xcb.xpath({field})).stringValue(),{section}))
[condition][]the {field} from positions {pos1} to {pos2} is not populated or spaces=((new Populated()).rangeOfPositionIsNotPopulatedOrSpaces((xcb.xpath({field})).stringValue(),{pos1},{pos2}))
[condition][]the {section}{field} is not populated in all occurence=((new Occurence()).VirtualNoOccurenceIsPopulated({section},(xcb.xpath({field})).stringValue()))
[condition][]responseMaximumLengthCheck {var0} {var1} {var2} {var3} =((new Occurence()).responseMaximumLengthCheck({var0},{var1},{var2},{var3}))
[condition][]the {field} has_the specified segment with number {segnum} whose length is in range {min} to {max} to support virgule or period as delimiter=((new LengthCheck()).virguleandPeriodSegmentNumberLengthInRange((xcb.xpath({field})).stringValue(),{segnum},{min},{max}))
[condition][]the {field} is Alpha with Special Characters=((new DatatypeCheck()).checkAlphaSP((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} has_the specified segment with number {segnum} whose length is in range {min} to {max} with leading spaces to support virgule or period as delimiter=(!((new LengthCheck()).virguleandPeriodSegmentRangeIsNumericWithLeadingSpaces((xcb.xpath({field})).stringValue(),{segnum},{min},{max})))
[condition][]it is not true that_spaceOrCharacterOrNumberInRange01_99 {var0} {var1} {var2} {var3} {var4} =(!((new Position()).spaceOrCharacterOrNumberInRange01_99({var0},{var1},{var2},{var3},{var4})))
[condition][]it is not true that_any occurance of the {fieldwithxpath} is not equal to {values} values=(!((new Occurence()).anyOccurenceNotEqualToValues((xcb.xpath({fieldwithxpath})).stringValue(),{values})))
[condition][]it is not true that_any one of the segment that may be delimeted by the char {delimchar} of the {field} does not contain {Alpha} Alpha character followed by maximum number {num} of numeric characters=(!((new LengthCheck()).segmentDoesNotContainsAlphaCountFollowedByNumericCount({delimchar},(xcb.xpath({field})).stringValue(),{Alpha},{num})))
[condition][]the {fieldwithxpath} is not prohibited=((new Prohibited()).isNotProhibited((xcb.xpath({fieldwithxpath})).stringValue()))
[condition][]it is not true that_the {field} has_the specified segment with number {segnum} whose length is in range {min} to {max} to support virgule or period as delimiter=(!((new LengthCheck()).virguleandPeriodSegmentNumberLengthInRange((xcb.xpath({field})).stringValue(),{segnum},{min},{max})))
[condition][]it is not true that_the difference between {fielddate1} and {fielddate2} is greater than or equal to one year=(!((new DateCheck()).isRangeGreaterThanOrEqualToOneYear((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue())))
[condition][]it is not true that_the {field} has_space as a special character=(!((new SpaceCheck()).spaceAsSpecialCharacter((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_all occurence of{section}{field} not equals{value} erroring to last occurence with{errorcode}=(!(virtualAllOccurenceOfFieldNotEqualsValue({section},(xcb.xpath({field})).stringValue(),{value},{errorcode})))
[condition][]it is not true that_the multiple field {field} is not numeric in any occurence=(!((new Occurence()).dataTypeCheckForMultipleOccuringTag((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_noconfirmationOrderCheck pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}=(!((new SuplementOrderCheck()).noConfirmationOrderCheck({pon},{ver},{ccna},{icsc},{description})))
[condition][]it is not true that_lrefTagCheck {var0} {var1} {var2} {var3} =(!((new SuplementOrderCheck()).lrefTagCheck({var0},{var1},{var2},{var3})))
[condition][]it is not true that_the {fieldvalue} is present on ICSC table=(!((new ASOGTABLE()).fetchAbbreviationICSCTable((xcb.xpath({fieldvalue})).stringValue())))
[condition][]the {field} has {N} number of segments=((new LengthCheck()).fieldHasNumberOfSegments((xcb.xpath({field})).stringValue(),{N}))
[condition][]it is not true that_the {field} has_all lowercase characters=(!((new CapitalLetterCheck()).isAllLowerCase((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the_section{section} parent{parent} tag {tag} has_value{value} in any occurence=(!(virtualAnyOccurenceOfSaliTagEqualsValue({section},{parent},{tag},{value})))
[condition][]the{section}{field} lengths not equals{value} with code {code}=(virtualResponseLengthCheck({section},(xcb.xpath({field})).stringValue(),{value},{code}))
[condition][]it is not true that_any occurance of the {field1withxpath} is equal to {value}=(!((new Occurence()).anyOccurenceEqualToValue((xcb.xpath({field1withxpath})).stringValue(),{value})))
[condition][]ccnaMultiEcIcscCheck {var0} {var1} {var2} =((new SuplementOrderCheck()).ccnaMultiEcIcscCheck({var0},{var1},{var2}))
[condition][]getRootXpath=((new Occurence()).getRootXpath())
[condition][]it is not true that_the {field} does not match with {compstring} having the specified Characters {numChar} from last within the comparison string=(!((new Position()).CompStringDoesntMatchWithSpecifiedChars((xcb.xpath({field})).stringValue(),{compstring},{numChar})))
[condition][]it is not true that_anyOccurenceOfFieldPopulatedAndAssosiatedTagNotEqualsValues {var0} {var1} {var2} {var3} {var4} =(!((new Occurence()).anyOccurenceOfFieldPopulatedAndAssosiatedTagNotEqualsValues({var0},{var1},{var2},{var3},{var4})))
[condition][]all occurences of{fieldwithxpath} not equals to{value}=((new Occurence()).allOccurenceOfFieldNotEqualToValue((xcb.xpath({fieldwithxpath})).stringValue(),{value}))
[condition][]vitualsvlanthirdOccurenceProhibit {vector} {errorcode} =((new Occurence()).vitualsvlanthirdOccurenceProhibit({vector},{errorcode}))
[condition][]the sup {SupFieldValue} is populated with pon {PonFieldValue} and version {VerFieldValue} and ccna {CcnaFieldValue} and icsc {IcscFieldValue} and the UNI_MAPPING section which had the field {FieldName} of values {commaseparatedvalues} and with all its elements of the previous order is not equal to none of the UNI_MAPPING section with all its elements in current order=((new SuplementOrderCheck()).checkActiveUrefDoesNotExists({SupFieldValue},{PonFieldValue},{VerFieldValue},{CcnaFieldValue},{IcscFieldValue},{FieldName},{commaseparatedvalues}))
[condition][]it is not true that_virtualoccurenceofuactRuid {vector} {list} {errorcode} =(!((new Occurence()).virtauloccurenceofuactRuid({vector},{list},{errorcode})))
[condition][]checkCcnaIcscCombinationInSECONDARYSOURCETARGETINFO {xmlInstance} {ccna} {icsc} =((new SuplementOrderCheck()).checkCcnaIcscCombinationInSECONDARYSOURCETARGETINFO({xmlInstance},{ccna},{icsc}))
[condition][]The field Date is a valid date in the format mmddyy=((new DateCheck()).isValidDate2())
[condition][]routing matrix value check when first column is ALL{section}{subsect}{field}=(virtualRoutingMatrixCheck2({section},{subsect},(xcb.xpath({field})).stringValue()))
[condition][]the {pos1} to {pos2} of the {field} is present in LOCATION Table=((new ASOGTABLE()).posToPosfetchAbbreviationLOCATIONTable({pos1},{pos2},(xcb.xpath({field})).stringValue()))
[condition][]the {field} is Required for {commaseperatedvalues}=((new Required()).requiredForValues((xcb.xpath({field})).stringValue(),{commaseperatedvalues}))
[condition][]it is not true that_the difference between {fielddate1} and {fielddate2} is not equal to one year=(!((new DateCheck()).isRangeNotEqualToOneYear((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue())))
[condition][]any of the {fieldwithxpath} has {character}=(virtualanyCharacterOfFieldIs((xcb.xpath({fieldwithxpath})).stringValue(),{character}))
[condition][]it is not true that_the field {field} is not numeric from postion {posn1} to position {posn2}=(!((new Contains()).positionalNotNumeric((xcb.xpath({field})).stringValue(),{posn1},{posn2})))
[condition][]the {fieldvalue} is present in NCMUX table =((new ASOGTABLE()).fetchAbbreviationNCMUXTable((xcb.xpath({fieldvalue})).stringValue()))
[condition][]the {field} is AlphaNumeric without following Special Character set {setofspecialcharacters}=((new DatatypeCheck()).checkAlphaNumericWithOutSPSet((xcb.xpath({field})).stringValue(),{setofspecialcharacters}))
[condition][]it is not true that_the {field} has_alpha characters in the specified range {start} to {end}=(!((new RangeOfValues()).numberOfAlphaInSpecRange((xcb.xpath({field})).stringValue(),{start},{end})))
[condition][]the {field} does not contain {CommaSeparatedValues}=((new Contains()).doesNotContains((xcb.xpath({field})).stringValue(),{CommaSeparatedValues}))
[condition][]it is not true that_the sup {SupFieldValue} is populated with pon {PonFieldValue} and version {VerFieldValue} and ccna {CcnaFieldValue} and icsc {IcscFieldValue} and qty {QtyFieldValue} on the current order which has_decreasing QTY with respect to the previous order=(!((new SuplementOrderCheck()).qtyFieldCheck({SupFieldValue},{PonFieldValue},{VerFieldValue},{CcnaFieldValue},{IcscFieldValue},{QtyFieldValue})))
[condition][]the {field} has_ampersand which is not preceeded and followed by space=((new SpaceCheck()).isAmpersandNotPrecFollSpace((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_noConfirmationOrderCheck {var0} {var1} {var2} {var3} =(!((new SuplementOrderCheck()).noConfirmationOrderCheck({var0},{var1},{var2},{var3})))
[condition][]the value of {field} not equals the occurences of{section}{subsectn}=(virtualsaliValueOfFieldNotEqualsOccurenceOfOtherSection((xcb.xpath({field})).stringValue(),{section},{subsectn}))
[condition][]the {field} has_time format as {timeformat}=((new TimeFormatCheck()).timeFormat((xcb.xpath({field})).stringValue(),{timeformat}))
[condition][]it is not true that_getXPathWithPosition {var0} {var1} =(!((new XpathLookup()).getXPathWithPosition({var0},{var1})))
[condition][]virtualoccOfF1POPnF2NOTPOPwithinsameUNIMAPPING {section} {errorcode} {field1} {field2} {field3} =(virtualoccOfF1POPnF2NOTPOPwithinsameUNIMAPPING({section},{errorcode},(xcb.xpath({field1})).stringValue(),(xcb.xpath({field2})).stringValue(),(xcb.xpath({field3})).stringValue()))
[condition][]it is not true that_eachCharacterPreceededOrFollowedByNumeric {var0} {var1} =(!((new Contains()).eachCharacterPreceededOrFollowedByNumeric({var0},{var1})))
[condition][]Is the {fieldDate1} not equal to {comparisonDate} in the format {CCYYMMDD}=((new DateFormatCheck()).isFieldNotEqualToComparisonDateInspecifiedFormat((xcb.xpath({fieldDate1})).stringValue(),{comparisonDate},{CCYYMMDD}))
[condition][]the ccna {fieldvalue} has_the license for the table {NCNCIICSCCLLI}=((new ASOGTABLE()).checkCcnaLicenseForTable((xcb.xpath({fieldvalue})).stringValue(),{NCNCIICSCCLLI}))
[condition][]it is not true that_the {field} has_an abbreviation name=(!((new ThoroughFareHelper()).fetchAbbreviationName((xcb.xpath({field})).stringValue())))
[condition][]virtualoccurenceofVACTandUACT3 {section} {errorcode} =(virtualoccurenceofVACTandUACT3({section},{errorcode}))
[condition][]the {pos} position_Of {field1} equal to {pos} position_Of {field2}=((new Contains()).positionOfFieldEqualToPositionOfField({pos},(xcb.xpath({field1})).stringValue(),{pos},(xcb.xpath({field2})).stringValue()))
[condition][]it is not true that_the {field} has_from the start position {pos} to end position {pos} the constant {constant} followed by a Dot and followed by {number} alphanumeric characters=(!((new DatatypeCheck()).constantFollowedByDotFollowedByAlphaNumeric((xcb.xpath({field})).stringValue(),{pos},{pos},{constant},{number})))
[condition][]atleast any one of the segment delimeted by the char {delimchar} of the {field} does not contain Alpha character followed by maximum number {num} of numeric characters=(virtualSegmentsDoesNotContainsAlphafollowedByNumerics({delimchar},(xcb.xpath({field})).stringValue(),{num}))
[condition][]it is not true that_setNCLicense {var0} =(!((new SvcType()).setNCLicense({var0})))
[condition][]it is not true that_the {field} has_date format as {format}=(!((new DateFormatCheck()).dateCheck((xcb.xpath({field})).stringValue(),{format})))
[condition][]it is not true that_checkResponsePonDoesNotExistInRequest {var0} {var1} {var2} =(!((new SuplementOrderCheck()).checkResponsePonDoesNotExistInRequest({var0},{var1},{var2})))
[condition][]The number of occurence of {path} populated is greater than {number}=((new Occurence()).NumberOfoccurencepopulatedisgreaterthan({path},{number}))
[condition][]the each position_from {pos1} to {pos2} of {field} is not_equal_to_values{commaseperatedvalues}=((new Position()).checkEachPositionsInRangeNotEqualToValues({pos1},{pos2},(xcb.xpath({field})).stringValue(),{commaseperatedvalues}))
[condition][]getvalue {var0} =((new Occurence()).getvalue({var0}))
[condition][]the each position_from {pos1} to {pos2} of {field} is not in between {startrange} and {endrange}=((new RangeOfValues()).checkPositionsInRangeNotPopulatedInRangeOfValues({pos1},{pos2},(xcb.xpath({field})).stringValue(),{startrange},{endrange}))
[condition][]it is not true that_the {field} has_both uppercase and lowercase characters=(!((new CapitalLetterCheck()).isUpperAndLowerCase((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {field} position {pos} and {pos} is greater than or equal to {pos} and {pos}=(!((new Contains()).checkPositionalValuesGreaterThanOrEqualTo((xcb.xpath({field})).stringValue(),{pos},{pos},{pos},{pos})))
[condition][]the {fielddate1} is a valid date=((new DateCheck()).isValidDate((xcb.xpath({fielddate1})).stringValue()))
[condition][]it is not true that_segmentRangeIsNumericWithLeadingSpaces {var0} {var1} {var2} {var3} =(!((new LengthCheck()).segmentRangeIsNumericWithLeadingSpaces({var0},{var1},{var2},{var3})))
[condition][]the {pos} and {pos} of {field} is_equal_to_values {CommaSeparatedValues}=((new Position()).twoPositionValueofTagEqualToValues({pos},{pos},(xcb.xpath({field})).stringValue(),{CommaSeparatedValues}))
[condition][]the {fieldwithxpath} occurance is atleast {numberoftimes}=((new Occurence()).atleastOccurenceOf((xcb.xpath({fieldwithxpath})).stringValue(),{numberoftimes}))
[condition][]the {field} contains roman numerals=((new Contains()).containsRoman((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the sup {SupFieldValue} is populated with pon {PonFieldValue} and version {VerFieldValue} and ccna {CcnaFieldValue} and icsc {IcscFieldValue} on the current order and matching with the previous order which has_a status COMPLETED=(!((new SuplementOrderCheck()).completionOrderCheck({SupFieldValue},{PonFieldValue},{VerFieldValue},{CcnaFieldValue},{IcscFieldValue})))
[condition][]the {fielddate1} is equal to {fielddate2}=((new DateCheck()).isEqualTo((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue()))
[condition][]it is not true that_allOccurenceOfFieldEqualToValue {var0} {var1} =(!((new Occurence()).allOccurenceOfFieldEqualToValue({var0},{var1})))
[condition][]it is not true that   new SuplementOrderCheck  checkTagValueInRequestforResponse  =(!((new SuplementOrderCheck()).checkTagValueInRequestforResponse()))
[condition][]it is not true that_the sup {SupFieldValue} is populated with act {ActFieldValue} and pon {PonFieldValue} and version {VerFieldValue} and ccna {CcnaFieldValue} and icsc {IcscFieldValue} on the current order and does not have same ACT on the previous order=(!((new SuplementOrderCheck()).actFieldCheck({SupFieldValue},{ActFieldValue},{PonFieldValue},{VerFieldValue},{CcnaFieldValue},{IcscFieldValue})))
[condition][]it is not true that_the {section} for lref when uact is not equal to CKT with {errorcode}=(!(virtuallrefProhibitedWhenUactNotEqualsCNK({section},{errorcode})))
[condition][]it is not true that_from the {pos1} to {pos2} has {format} for the {field}=(!((new DateFormatCheck()).time_format_chk({pos1},{pos2},{format},(xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {field} is compared with the specified positions {pos1} to {pos2} with values {value1} or {value2}=(!((new Position()).compareCharAtAnyPositionWithAnyValue((xcb.xpath({field})).stringValue(),{pos1},{pos2},{value1},{value2})))
[condition][]it is not true that_the {field} contains roman numerals=(!((new Contains()).containsRoman((xcb.xpath({field})).stringValue())))
[condition][]the {field} has_segment with specified {segnum} of the specified {length}=((new LengthCheck()).segmentNumberLengthEqualTo((xcb.xpath({field})).stringValue(),{segnum},{length}))
[condition][]the {field} has_consecutive uppercase characters and should not be followed by space=((new CapitalLetterCheck()).consecUpperCaseWithNoSpaceAfter((xcb.xpath({field})).stringValue()))
[condition][]the {field} with segment{segnum} is populated=((new DatatypeCheck()).segmentPopulated((xcb.xpath({field})).stringValue(),{segnum}))
[condition][]it is not true that_the {field} has_valid values {commaseperatedvalues}=(!((new isValidValue()).isValidValues((xcb.xpath({field})).stringValue(),{commaseperatedvalues})))
[condition][]the message type for the valid interface equals {values}=((new SuplementOrderCheck()).checkMessageType({values}))
[condition][]it is not true that_the maximum length of {field} is {value}=(!((new LengthCheck()).checkMaximumlength((xcb.xpath({field})).stringValue(),{value})))
[condition][]the occurance of {fieldwithxpath} is equal to {number}=((new Occurence()).noOfOccurenceEqualTo((xcb.xpath({fieldwithxpath})).stringValue(),{number}))
[condition][]the ASR Request order exists for the pon {PON} ccna {CCNA} and icsc {ICSC}=((new SuplementOrderCheck()).checkRequestPonExistsInDatabase({PON},{CCNA},{ICSC}))
[condition][]the {field} from {pos1} to {pos2} of the segment{segnum} are not alpha characters to supportvirgule or period as delimiter=((new LengthCheck()).virguleandPeriodPosToPosOfSegmentAreNotAlpha((xcb.xpath({field})).stringValue(),{pos1},{pos2},{segnum}))
[condition][]the {field} from positions {pos1} to {pos2} is populated or not spaces=((new Populated()).rangeOfPositionIsPopulatedOrNotSpaces((xcb.xpath({field})).stringValue(),{pos1},{pos2}))
[condition][]it is not true that_the field {fieldname} of {parentname} with value {fieldvalue} differs from previous version tag value for the pon {PON} version {VER} ccna {CCNA} and icsc{ICSC}=(!((new SuplementOrderCheck()).tagValueDiffersInPreviousVersion((xcb.xpath({fieldname})).stringValue(),{parentname},(xcb.xpath({fieldvalue})).stringValue(),{PON},{VER},{CCNA},{ICSC})))
[condition][]it is not true that_the {pos} position_Of {field1} equal to {pos} position_Of {field2}=(!((new Contains()).positionOfFieldEqualToPositionOfField({pos},(xcb.xpath({field1})).stringValue(),{pos},(xcb.xpath({field2})).stringValue())))
[condition][]the {field} has_last character as upper which is followed by lower case character=((new CapitalLetterCheck()).lastCharUpperFollLower((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_setCLLILicense {var0} =(!((new SvcType()).setCLLILicense({var0})))
[condition][]occurenceOfFieldIsGreaterThanSpecifiedNumberWithGivenValue {var0} {var1} {var2} =((new Occurence()).occurenceOfFieldIsGreaterThanSpecifiedNumberWithGivenValue({var0},{var1},{var2}))
[condition][]the {pos} position_of {field1} is equal to {pos} position_of {field2}=((new Position()).positionOfOneFieldIsEqualToPositionOfAnother({pos},(xcb.xpath({field1})).stringValue(),{pos},(xcb.xpath({field2})).stringValue()))
[condition][]the segment {segnum} length of the field {fieldvalue} is in the range {min} and {max}=(virtualSegmentNumberLengthInRange({segnum},(xcb.xpath({fieldvalue})).stringValue(),{min},{max}))
[condition][]the {fieldwithxpath} occurance is atmost {numberoftimes}=((new Occurence()).atmostOccurenceOf((xcb.xpath({fieldwithxpath})).stringValue(),{numberoftimes}))
[condition][]it is not true that_the {field} is Alpha with Special Characters=(!((new DatatypeCheck()).checkAlphaSP((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the interval between {fielddate1} and {fielddate2} is less than or equal to {days}=(!((new DateCheck()).intervalBetweenTwoDateIsLessThanOrEqualtoDays((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue(),{days})))
[condition][]it is not true that_the_section {section} for the field {feild} with {compvalue} and {innercompvalue} for field {innerfeild} and {errorcode}=(!(virtualoccurenceofSvlanMapping({section},{feild},{compvalue},{innercompvalue},{innerfeild},{errorcode})))
[condition][]it is not true that_the {field} has_specified segment {segnum} which contains alpha numeric characters with virgule or period as delimiter=(!((new DatatypeCheck()).virguleandPeriodSegmentEqualToAlphaNumeric((xcb.xpath({field})).stringValue(),{segnum})))
[condition][]it is not true that_the {field} has_segment with specified {segnum} of the specified {length} to support virgule or period=(!((new LengthCheck()).virguleandPeriodSegmentNumberLengthEqualTo((xcb.xpath({field})).stringValue(),{segnum},{length})))
[condition][]it is not true that_the {field} does not match with {field2} at the specified character positions {pos1} to {pos2}=(!((new Position()).compStringDoesntMatchTagValueAtSpecPosition((xcb.xpath({field})).stringValue(),(xcb.xpath({field2})).stringValue(),{pos1},{pos2})))
[condition][]it is not true that_virguleandPeriodSegmentValueEqualToValues {var0} {var1} {var2} =(!((new Equals()).virguleandPeriodSegmentValueEqualToValues({var0},{var1},{var2})))
[condition][]it is not true that_checkCancelledUrefExists {var0} {var1} {var2} {var3} {var4} {var5} {var6} =(!((new SuplementOrderCheck()).checkCancelledUrefExists({var0},{var1},{var2},{var3},{var4},{var5},{var6})))
[condition][]virtualoccurenceofVACTandUACT2CEVLAN {var0} {var1} =(virtualoccurenceofVACTandUACT2CEVLAN({var0},{var1}))
[condition][]the {field} is not equal to specified val {val}=((new Equals()).fieldnoteqval((xcb.xpath({field})).stringValue(),{val}))
[condition][]segmentValueEquals {var0} {var1} {var2} =((new Equals()).segmentValueEquals({var0},{var1},{var2}))
[condition][]any Occurnce of {fieldwithxpath} is equal to {character} in {pos}positon=((new Occurence()).positionOfAnyFieldEqualToCharacter((xcb.xpath({fieldwithxpath})).stringValue(),{character},{pos}))
[condition][]the {field} equals {value}=((new Equals()).isEquals((xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_the field differs from previous version for the pon {PON} version {VER} icsc{ICSC} and ccna{CCNA} {fieldname} of {parentname} at pos{POS} with fieldvalue {fieldvalue}=(!((new SuplementOrderCheck()).fieldDiffersFromPreviousVersionatspecpos({PON},{VER},{ICSC},{CCNA},(xcb.xpath({fieldname})).stringValue(),{parentname},{POS},(xcb.xpath({fieldvalue})).stringValue())))
[condition][]it is not true that_the maximum length of the trimmed field {fieldvalue} is {length}=(!(virtualCheckMaximumLengthOfTrimmedTag((xcb.xpath({fieldvalue})).stringValue(),{length})))
[condition][]it is not true that_the {field} has_all uppercase characters for comma seperated values=(!((new CapitalLetterCheck()).isAllUpperCaseForCSV((xcb.xpath({field})).stringValue())))
[condition][]positionOfAllFieldNotEqualToCharacter {var0} {var1} {var2} =((new Occurence()).positionOfAllFieldNotEqualToCharacter({var0},{var1},{var2}))
[condition][]it is not true that_the {field} is AlphaNumeric with following Special Character set {setofspecialcharacters}=(!((new DatatypeCheck()).checkAlphaNumericSPSet((xcb.xpath({field})).stringValue(),{setofspecialcharacters})))
[condition][]the {field} contains {CommaSeparatedValues}=((new Contains()).contains((xcb.xpath({field})).stringValue(),{CommaSeparatedValues}))
[condition][]Number of occurence of Field {FieldXpath} is in range from {minvalue} To {maxvalue}=((new Occurence()).noOfOccurenceOfFieldInRange({FieldXpath},{minvalue},{maxvalue}))
[condition][]the value of{field} is not equal to occurence of the {fieldwithxpath}=((new Occurence()).valueOfFieldIsNotEqualToccurenceOfAnotherField((xcb.xpath({field})).stringValue(),(xcb.xpath({fieldwithxpath})).stringValue()))
[condition][]the {field} has_date format check1 {format1}=((new DateFormatCheck()).dateCheck1((xcb.xpath({field})).stringValue(),{format1}))
[condition][]it is not true that_virtualisIntervalDurationMatchingForNc {var0} {var1} =(!(virtualisIntervalDurationMatchingForNc({var0},{var1})))
[condition][]it is not true that_the {field} is Numeric=(!((new DatatypeCheck()).checkNumeric((xcb.xpath({field})).stringValue())))
[condition][]the {field} has {commaseperatedvalues}=((new ValidValueCheck()).validCommaSeperatedValue((xcb.xpath({field})).stringValue(),{commaseperatedvalues}))
[condition][]it is not true that_{field} has_atleast {occurance} occurances populated=(!((new Occurence()).atleastOccurenceOfTagPopulated((xcb.xpath({field})).stringValue(),{occurance})))
[condition][]noConfirmationOrderCheck {var0} {var1} {var2} {var3} =((new SuplementOrderCheck()).noConfirmationOrderCheck({var0},{var1},{var2},{var3}))
[condition][]it is not true that_virtualCanopiWebService {var0} =(!(virtualCanopiWebService({var0})))
[condition][]it is not true that_the position {pos1} and {pos2} of {field} is between {startrange} and {endrange}=(!((new RangeOfValues()).twoFieldPositionInRange({pos1},{pos2},(xcb.xpath({field})).stringValue(),{startrange},{endrange})))
[condition][]the {field} is equal or greater than {value}=((new Equals()).isEqualOrGreaterThan((xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_the {pos} and {pos} of {field} is not_equal_to_values {CommaSeparatedValues}=(!((new Position()).twoPositionValueofTagNotEqualToValues({pos},{pos},(xcb.xpath({field})).stringValue(),{CommaSeparatedValues})))
[condition][]it is not true that_the interval between {fielddate1} and {fielddate2} is less than {days}=(!((new DateCheck()).intervalBetweenTwoDateIsLessThanDays((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue(),{days})))
[condition][]it is not true that_the {field} is in the range A1 to Z99=(!((new RangeOfValues()).rangeCheckA1_Z99((xcb.xpath({field})).stringValue())))
[condition][]it is not true that_the {fielddate1} is greater than {fielddate2}=(!((new DateCheck()).isGreaterThan((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue())))
[condition][]timeFormatWithRange {var0} {var1} {var2} =((new TimeFormatCheck()).timeFormatWithRange({var0},{var1},{var2}))
[condition][]asogCutOverOrderReject {ver} {icsc} {msgtimestamp} =((new AsogGuidelineVersion()).asogCutOverOrderReject({ver},{icsc},{msgtimestamp}))
[condition][]it is not true that_the pon {PON} ccna {CCNA}  icsc{ICSC} and ver{ver} combination has_the response with description {DESCRIPTION} and the previous version SUP1 order with status {CURRENTSTATUS} for the xml {xmlins}=(!(virtual_prevOrderSUP1CheckWithRespAccept({PON},{CCNA},{ICSC},{ver},{DESCRIPTION},{CURRENTSTATUS},{xmlins})))
[condition][]it is not true that_the {field} has_specified segment {segnum} which contains alpha numeric characters=(!((new DatatypeCheck()).segmentEqualToAlphaNumeric((xcb.xpath({field})).stringValue(),{segnum})))
[condition][]it is not true that_the segment {segnum} length of field {fieldvalue} is in the range {min} and {max}=(!((new LengthCheck()).segmentNumberLengthInRange({segnum},(xcb.xpath({fieldvalue})).stringValue(),{min},{max})))
[condition][]it is not true that_the {field} contains invalid values or with valid values {commaseparatedvalues} without spaces between them or repeated=(!((new Contains()).containsInvalidOrValidWithoutSpaceOrRepeated((xcb.xpath({field})).stringValue(),{commaseparatedvalues})))
[condition][]it is not true that_the {field} is Alpha without Special Characters Set {setofspecialcharacters}=(!((new DatatypeCheck()).checkAlphaWithOutSPSet((xcb.xpath({field})).stringValue(),{setofspecialcharacters})))
[condition][]number of occurences{fieldwithxpath} equals{value}=((new Occurence()).noOfOccurenceEqualsValue((xcb.xpath({fieldwithxpath})).stringValue(),{value}))
[condition][] new SuplementOrderCheck  checkResponseTagExistInRequest  =((new SuplementOrderCheck()).checkResponseTagExistInRequest())
[condition][]the difference between {fielddate1} and {fielddate2} is equal to one year=((new DateCheck()).isRangeEqualToOneYear((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue()))
[condition][]the {fieldwithxpath} is prohibited=((new Prohibited()).isProhibited((xcb.xpath({fieldwithxpath})).stringValue()))
[condition][]it is not true that_noconfirmationOrderCheckNew pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}dedicate_recieve_customer{drc}=(!((new SuplementOrderCheck()).noConfirmationOrderCheckNew({pon},{ver},{ccna},{icsc},{description},{drc})))
[condition][]it is not true that_the field {field} with segment {segnum} is populated=(!((new Populated()).segmentIsPopulated((xcb.xpath({field})).stringValue(),{segnum})))
[condition][]it is not true that_the {fieldName} in {parentSection} is less than {fieldValue} for the {pon} {ver} {ccna} {icsc}=(!((new SuplementOrderCheck()).isCurrentDDDLessThanPreviousVersionDDD((xcb.xpath({fieldName})).stringValue(),{parentSection},(xcb.xpath({fieldValue})).stringValue(),{pon},{ver},{ccna},{icsc})))
[condition][]it is not true that_confirmationOrderCheckDes pon{pon}ver{ver}ccna{ccna}icsc{icsc}description{description}=(!((new SuplementOrderCheck()).confirmationOrderCheckDes({pon},{ver},{ccna},{icsc},{description})))
[condition][]it is not true that_responseMaximumLengthCheck {var0} {var1} {var2} {var3} =(!((new Occurence()).responseMaximumLengthCheck({var0},{var1},{var2},{var3})))
[condition][]the CKTACT field check pon{pon} ver{ver} ccna{ccna} icsc{icsc} and xpath{xpath} tag{tag} with value{value} for rule{ruleErrorCode}=((new Occurence()).cktActCheck({pon},{ver},{ccna},{icsc},{xpath},{tag},{value},{ruleErrorCode}))
[condition][]it is not true that_the {field} is Alpha=(!((new DatatypeCheck()).checkAlpha((xcb.xpath({field})).stringValue())))
[condition][]the last character Of {field} is {value}=((new Equals()).lastCharacterOfField((xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_the {fieldwithxpath} is not required=(!((new Required()).isNotRequired((xcb.xpath({fieldwithxpath})).stringValue())))
[condition][]the_length_of {field} is equal to {value}=((new LengthCheck()).checkLength((xcb.xpath({field})).stringValue(),{value}))
[condition][]it is not true that_the {field} is less than {value}=(!((new Equals()).isLessThan((xcb.xpath({field})).stringValue(),{value})))
[condition][]it is not true that_the {field} equals {value}=(!((new Equals()).isEquals((xcb.xpath({field})).stringValue(),{value})))
[condition][]it is not true that_the version is {VER} not equal to the latest database version for the pon {PON} ccna {CCNA} and icsc{ICSC} with the status {STATUS}=(!((new SuplementOrderCheck()).verNotEqualToLatestDBVersion({VER},{PON},{CCNA},{ICSC},{STATUS})))
[condition][]it is not true that_the {field} from positions {pos1} to {pos2} is populated or spaces=(!((new Populated()).rangeOfPositionIsPopulatedOrSpaces((xcb.xpath({field})).stringValue(),{pos1},{pos2})))
[condition][]any occurance of the {fieldwithxpath} is not equal to {values} values=((new Occurence()).anyOccurenceNotEqualToValues((xcb.xpath({fieldwithxpath})).stringValue(),{values}))
[condition][]it is not true that_the {fieldvalue} is populated in segment {segnum} after {value}=(!(virtualPositionAfterDelimeterPopulated((xcb.xpath({fieldvalue})).stringValue(),{segnum},{value})))
[condition][]isValidDate1 {var0} =((new DateCheck()).isValidDate1({var0}))
[condition][]the field value {fieldvalue} do_not_matches the pattern {pattern}=((new SpecialFormat()).isPatternNotMatches((xcb.xpath({fieldvalue})).stringValue(),{pattern}))
[condition][]it is not true that_the {field} is not numeric with special character set{spcharacters}=(!((new DatatypeCheck()).notNumericWithAllSpSet((xcb.xpath({field})).stringValue(),{spcharacters})))
[condition][]it is not true that_the_section{section} parent{parent} tag {tag} does not have value{value} in any occurence=(!(virtualNoneOccurenceEqualsValue({section},{parent},{tag},{value})))
[condition][]it is not true that_any occurance of {fieldwithxpath} is there=(!((new Occurence()).anyOccurenceOf((xcb.xpath({fieldwithxpath})).stringValue())))
[condition][]it is not true that_the {field} contains {num} of consecutive uppercase Alpha Characters=(!((new CapitalLetterCheck()).containsConsecutiveUppercaseAlphaCharacters((xcb.xpath({field})).stringValue(),{num})))
[condition][]the {field} position {pos} and {pos} is greater than or equal to {pos} and {pos}=((new Contains()).checkPositionalValuesGreaterThanOrEqualTo((xcb.xpath({field})).stringValue(),{pos},{pos},{pos},{pos}))
[condition][]it is not true that_Check for reqtyp{field} pon{field}ver{ver}ccna{ccna}icsc{icsc}=(!((new SuplementOrderCheck()).reqtypFieldCheck((xcb.xpath({field})).stringValue(),(xcb.xpath({field})).stringValue(),{ver},{ccna},{icsc})))
[condition][]it is not true that_the {field} is in the range ZL1 to ZL8=(!((new RangeOfValues()).rangeCheckZl1_Zl8((xcb.xpath({field})).stringValue())))
[condition][]the {field} is Numeric with Special Characters Set {setofspecialcharacters}=((new DatatypeCheck()).checkNumericSPSet((xcb.xpath({field})).stringValue(),{setofspecialcharacters}))
[condition][]it is not true that_any occurence of the {fieldwithxpath} is populated in Response=(!((new Occurence()).anyOccurenceOfFieldPopulatedInRespose((xcb.xpath({fieldwithxpath})).stringValue())))
[condition][]it is not true that_vitualsvlanthirdOccurenceProhibit {vector} {errorcode} =(!((new Occurence()).vitualsvlanthirdOccurenceProhibit({vector},{errorcode})))
[condition][]getXPathWithPosition {var0} {var1} =((new XpathLookup()).getXPathWithPosition({var0},{var1}))
[condition][]it is not true that_the pos {pos} in any of the segment delimeted by the char {delimchar} of the {field} does not equal {commaseparatedvalues}=(!(virtualPosOfSegmentsDoesNotEquals({pos},{delimchar},(xcb.xpath({field})).stringValue(),{commaseparatedvalues})))
[condition][]segmentEqualToAlphaNumericWithSPChar {var0} {var1} {var2} =((new DatatypeCheck()).segmentEqualToAlphaNumericWithSPChar({var0},{var1},{var2}))
[condition][]it is not true that_the position_of Numeric is {pos} in {field}=(!((new DatatypeCheck()).checkPositionNumeric({pos},(xcb.xpath({field})).stringValue())))
[condition][]the {field} doesnot have {N} number of segments=((new LengthCheck()).fieldDoesNothaveNumberOfSegments((xcb.xpath({field})).stringValue(),{N}))
[condition][]anyOccurenceOfSaliTagEqualsValue {var0} {var1} {var2} {var3} {var4} =((new Occurence()).anyOccurenceOfSaliTagEqualsValue({var0},{var1},{var2},{var3},{var4}))
[condition][]timeRange {var0} {var1} {var2} =((new TimeFormatCheck()).timeRange({var0},{var1},{var2}))
[condition][]it is not true that_the difference between {fielddate1} and {fielddate2} is greater than one year=(!((new DateCheck()).isRangeGreaterThanOneYear((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue())))
[condition][]the {field} is compared with its position {pos1} to {pos2} with values {values}=((new Position()).compareCharAtAnyPositionWithAnyNumberOfValue((xcb.xpath({field})).stringValue(),{pos1},{pos2},{values}))
[condition][]it is not true that_comparePrevVerAndCurrVerFieldValue {var0} {var1} {var2} {var3} {var4} {var5} {var6} {var7} {var8} {var9} {var10} =(!((new SuplementOrderCheck()).comparePrevVerAndCurrVerFieldValue({var0},{var1},{var2},{var3},{var4},{var5},{var6},{var7},{var8},{var9},{var10})))
[condition][]it is not true that_the {field} is not equal to specified val {val}=(!((new Equals()).fieldnoteqval((xcb.xpath({field})).stringValue(),{val})))
[condition][]set the request type of to {var0}=((new ReqTypeAct()).setRequestType({var0}))
[condition][]it is not true that_the difference between {fielddate1} and {fielddate2} is greater than specified {fieldmonths}=(!((new DateCheck()).isRangeGreaterThanSpecifiedMonths((xcb.xpath({fielddate1})).stringValue(),(xcb.xpath({fielddate2})).stringValue(),(xcb.xpath({fieldmonths})).stringValue())))
[condition][]it is not true that_getRootXpath=(!((new Occurence()).getRootXpath()))
[condition][]the pos {pos} in any of the segment delimeted by the char {delimchar} of the {field} does not equal {commaseparatedvalues}=(virtualPosOfSegmentsDoesNotEquals({pos},{delimchar},(xcb.xpath({field})).stringValue(),{commaseparatedvalues}))
[condition][]any occurence of field{section}{field} is not populated and assosiated tag{tag} equals {values} and corresponding tag{tag} equals {values}=(virtualAnyOccurenceOfFieldNotPopulatedAndAssosiatedTagEqualsValuesAndCorrespondingTagEqualsValues({section},(xcb.xpath({field})).stringValue(),{tag},{values},{tag},{values}))
[consequence][]the error code {field1} the error message {field2} for the field {field3}=(xcb.logError({field1},{field2},{field3}))
[condition][]the {section} {field} is not unique in all the occurences with errorCode {errorcode} and errorMessage {errormessage}=FieldShouldNotUnique(xcb,{section},{field},{errorcode},{errormessage})
[condition][]xcb object=xcb : XOMContainerBean()
[condition][]Evaluate=eval
[condition][]Start Brace=(
[condition][]End Brace=)
[condition][]AND=&&
[condition][]OR=||
